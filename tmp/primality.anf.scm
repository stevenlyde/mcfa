(let ((square (if #f 'undefined)))  (let ((modulo-power (if #f 'undefined)))  (let ((jacobi (if #f 'undefined)))  (let ((random-char (if #f 'undefined)))  (let ((random-num (if #f 'undefined)))  (let ((random-bit (if #f 'undefined)))  (let ((random-byte (if #f 'undefined)))  (let ((random (if #f 'undefined)))  (let ((is-trivial-composite? (if #f 'undefined)))  (let ((is-fermat-prime? (if #f 'undefined)))  (let ((is-solovay-strassen-prime? (if #f 'undefined)))  (let ((generate-fermat-prime (if #f 'undefined)))  (let ((generate-solovay-strassen-prime (if #f 'undefined)))  (let ((iterations (if #f 'undefined)))  (let ((byte-size (if #f 'undefined)))  (let ((_ (if #f 'undefined)))  (let ((_ (if #f 'undefined)))  (let ((_ (if #f 'undefined)))  (let ((_ (if #f 'undefined)))  (let ((_ (if #f 'undefined)))  (let ((_ (if #f 'undefined)))  (let ((_ (if #f 'undefined)))  (let (($tmp$$40 (lambda (x)  (begin  (* x x)))))  (set! square $tmp$$40)) (let (($tmp$$39 (lambda (base exp n)  (begin  (let (($tmp$$37 (= exp 0)))  (if $tmp$$37 1 (let (($tmp$$38 (odd? exp)))  (if $tmp$$38 (modulo (* base (modulo-power base (- exp 1) n)) n) (modulo (square (modulo-power base (/ exp 2) n)) n)))))))))  (set! modulo-power $tmp$$39)) (let (($tmp$$36 (lambda (a n)  (begin  (let (($tmp$$27 (= n 1)))  (if $tmp$$27 1 (let (($tmp$$28 (= a 1)))  (if $tmp$$28 1 (let (($tmp$$29 (not (= (gcd a n) 1))))  (if $tmp$$29 0 (let ((n-mod-8 (modulo n 8)))  (let (($tmp$$30 (or (= n-mod-8 1) (= n-mod-8 7))))  (let (($tmp$$26 (and (= a 2) (if $tmp$$30 1 (let (($tmp$$31 (or (= n-mod-8 3) (= n-mod-8 5))))  (if $tmp$$31 -1 (void )))))))  (if $tmp$$26 $tmp$$26 (let (($tmp$$32 (> a n)))  (if $tmp$$32 (jacobi (modulo a n) n) (let (($tmp$$33 (even? a)))  (if $tmp$$33 (* (jacobi (/ a 2) n) (jacobi 2 n)) (let (($tmp$$34 (even? n)))  (if $tmp$$34 (* (jacobi a (/ n 2)) (jacobi a 2)) (let (($tmp$$35 (even? (/ (* (- a 1) (- n 1)) 4))))  (* (jacobi n a) (if $tmp$$35 1 -1)))))))))))))))))))))))  (set! jacobi $tmp$$36)) (let (($tmp$$25 (lambda ()  (begin  (call-with-input-file "/dev/random" (lambda (port)  (begin  (read-char port))))))))  (set! random-char $tmp$$25)) (let (($tmp$$24 (lambda ()  (begin  (let ((n (char->integer (random-char ))))  (let (($tmp$$23 (= n 65533)))  (if $tmp$$23 (random-num ) n)))))))  (set! random-num $tmp$$24)) (let (($tmp$$22 (lambda ()  (begin  (modulo (random-num ) 2)))))  (set! random-bit $tmp$$22)) (let (($tmp$$21 (lambda ()  (begin  (+ (modulo (random-num ) 128) (* 128 (random-bit )))))))  (set! random-byte $tmp$$21)) (let (($tmp$$20 (lambda (bytes)  (begin  (let (($tmp$$19 (<= bytes 0)))  (if $tmp$$19 0 (+ (* 256 (random (- bytes 1))) (random-byte ))))))))  (set! random $tmp$$20)) (let (($tmp$$18 (lambda (n)  (begin  (or (= (modulo n 2) 0) (= (modulo n 3) 0) (= (modulo n 5) 0) (= (modulo n 7) 0) (= (modulo n 11) 0) (= (modulo n 13) 0) (= (modulo n 17) 0) (= (modulo n 19) 0) (= (modulo n 23) 0))))))  (set! is-trivial-composite? $tmp$$18)) (let (($tmp$$17 (lambda (n iterations)  (begin  (let ((byte-size (ceiling (/ (log n) (log 2)))))  (let ((a (random byte-size)))  (let (($tmp$$16 (= (modulo-power a (- n 1) n) 1)))  (or (<= iterations 0) (if $tmp$$16 (is-fermat-prime? n (- iterations 1)) #f)))))))))  (set! is-fermat-prime? $tmp$$17)) (let (($tmp$$15 (lambda (n iterations)  (begin  (let (($tmp$$12 (<= iterations 0)))  (if $tmp$$12 #t (let (($tmp$$13 (and (even? n) (not (= n 2)))))  (if $tmp$$13 #f (let ((byte-size (ceiling (/ (log n) (log 2)))))  (let ((a (+ 1 (modulo (random byte-size) (- n 1)))))  (let ((jacobi-a-n (jacobi a n)))  (let ((exp (modulo-power a (/ (- n 1) 2) n)))  (let (($tmp$$14 (or (= jacobi-a-n 0) (not (= (modulo jacobi-a-n n) exp)))))  (if $tmp$$14 #f (is-solovay-strassen-prime? n (- iterations 1))))))))))))))))  (set! is-solovay-strassen-prime? $tmp$$15)) (let (($tmp$$11 (lambda (byte-size iterations)  (begin  (let ((n (random byte-size)))  (let (($tmp$$10 (and (not (is-trivial-composite? n)) (is-fermat-prime? n iterations))))  (if $tmp$$10 n (generate-fermat-prime byte-size iterations))))))))  (set! generate-fermat-prime $tmp$$11)) (let (($tmp$$9 (lambda (byte-size iterations)  (begin  (let ((n (generate-fermat-prime byte-size 5)))  (let (($tmp$$8 (is-solovay-strassen-prime? n iterations)))  (if $tmp$$8 n (generate-solovay-strassen-prime byte-size iterations))))))))  (set! generate-solovay-strassen-prime $tmp$$9)) (set! iterations 10) (set! byte-size 15) (let (($tmp$$7 (display "Generating prime...")))  (set! _ $tmp$$7)) (let (($tmp$$6 (newline )))  (set! _ $tmp$$6)) (let (($tmp$$5 (display (generate-solovay-strassen-prime byte-size iterations))))  (set! _ $tmp$$5)) (let (($tmp$$4 (display " is prime with at least probability 1 - 1/2^")))  (set! _ $tmp$$4)) (let (($tmp$$3 (display iterations)))  (set! _ $tmp$$3)) (let (($tmp$$2 (display ".")))  (set! _ $tmp$$2)) (let (($tmp$$1 (newline )))  (set! _ $tmp$$1)) (if #f 'undefined)))))))))))))))))))))))
