Input program:
(define extended-gcd (lambda (a b )  (if (= (modulo a b ) 0 ) (cons 0 1 ) (let* ((x:y (extended-gcd b (modulo a b ) )) (x (car x:y )) (y (cdr x:y )))  (cons y (- x (* y (quotient a b ) ) ) )))))

(define modulo-inverse (lambda (a n )  (modulo (car (extended-gcd a n ) ) n )))

(define totient (lambda (p q )  (* (- p 1 ) (- q 1 ) )))

(define square (lambda (x )  (* x x )))

(define modulo-power (lambda (base exp n )  (if (= exp 0 ) 1 (if (odd? exp ) (modulo (* base (modulo-power base (- exp 1 ) n ) ) n ) (modulo (square (modulo-power base (/ exp 2 ) n ) ) n )))))

(define is-legal-public-exponent? (lambda (e p q )  (and (< 1 e ) (< e (totient p q ) ) (= 1 (gcd e (totient p q ) ) ) )))

(define private-exponent (lambda (e p q )  (if (is-legal-public-exponent? e p q ) (modulo-inverse e (totient p q ) ) (error "Not a legal public exponent for that modulus." ))))

(define encrypt (lambda (m e n )  (if (> m n ) (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))

(define decrypt (lambda (c d n )  (modulo-power c d n )))

(define p 41)

(define q 47)

(define n (* p q ))

(define e 7)

(define d (private-exponent e p q ))

(define plaintext 42)

(define ciphertext (encrypt plaintext e n ))

(define decrypted-ciphertext (decrypt ciphertext d n ))

(display "The plaintext is:            " )

(display plaintext )

(newline  )

(display "The ciphertext is:           " )

(display ciphertext )

(newline  )

(display "The decrypted ciphertext is: " )

(display decrypted-ciphertext )

(newline  )

(if (not (= plaintext decrypted-ciphertext ) ) (error "RSA fail!" ) )


ANF program:
(let ((extended-gcd 'undefined))  (let ((modulo-inverse 'undefined))  (let ((totient 'undefined))  (let ((square 'undefined))  (let ((modulo-power 'undefined))  (let ((is-legal-public-exponent? 'undefined))  (let ((private-exponent 'undefined))  (let ((encrypt 'undefined))  (let ((decrypt 'undefined))  (let ((p 'undefined))  (let ((q 'undefined))  (let ((n 'undefined))  (let ((e 'undefined))  (let ((d 'undefined))  (let ((plaintext 'undefined))  (let ((ciphertext 'undefined))  (let ((decrypted-ciphertext 'undefined))  (let ((_$$1 'undefined))  (let ((_$$2 'undefined))  (let ((_$$3 'undefined))  (let ((_$$4 'undefined))  (let ((_$$5 'undefined))  (let ((_$$6 'undefined))  (let ((_$$7 'undefined))  (let ((_$$8 'undefined))  (let ((_$$9 'undefined))  (let ((_$$10 'undefined))  (begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) (void)) (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) (void)) (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) (void)) (begin  (set! square (lambda (x )  (* x x ))) (void)) (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) (void)) (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) (void)) (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) (void)) (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) (void)) (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) (void)) (begin  (set! p 41) (void)) (begin  (set! q 47) (void)) (let (($tmp$$17 (* p q )))  (begin  (set! n $tmp$$17) (void))) (begin  (set! e 7) (void)) (let (($tmp$$16 (private-exponent e p q )))  (begin  (set! d $tmp$$16) (void))) (begin  (set! plaintext 42) (void)) (let (($tmp$$15 (encrypt plaintext e n )))  (begin  (set! ciphertext $tmp$$15) (void))) (let (($tmp$$14 (decrypt ciphertext d n )))  (begin  (set! decrypted-ciphertext $tmp$$14) (void))) (let (($tmp$$13 (display "The plaintext is:            " )))  (begin  (set! _$$1 $tmp$$13) (void))) (let (($tmp$$12 (display plaintext )))  (begin  (set! _$$2 $tmp$$12) (void))) (let (($tmp$$11 (newline  )))  (begin  (set! _$$3 $tmp$$11) (void))) (let (($tmp$$10 (display "The ciphertext is:           " )))  (begin  (set! _$$4 $tmp$$10) (void))) (let (($tmp$$9 (display ciphertext )))  (begin  (set! _$$5 $tmp$$9) (void))) (let (($tmp$$8 (newline  )))  (begin  (set! _$$6 $tmp$$8) (void))) (let (($tmp$$7 (display "The decrypted ciphertext is: " )))  (begin  (set! _$$7 $tmp$$7) (void))) (let (($tmp$$6 (display decrypted-ciphertext )))  (begin  (set! _$$8 $tmp$$6) (void))) (let (($tmp$$5 (newline  )))  (begin  (set! _$$9 $tmp$$5) (void))) (let (($tmp$$1 (= plaintext decrypted-ciphertext )))  (let (($tmp$$2 (not $tmp$$1 )))  (let (($tmp$$3 (error "RSA fail!" )))  (let (($tmp$$4 (if $tmp$$2 $tmp$$3 )))  (begin  (set! _$$10 $tmp$$4) (void)))))) _$$10)))))))))))))))))))))))))))


CPS program:
((lambda (extended-gcd )  ((lambda (modulo-inverse )  ((lambda (totient )  ((lambda (square )  ((lambda (modulo-power )  ((lambda (is-legal-public-exponent? )  ((lambda (private-exponent )  ((lambda (encrypt )  ((lambda (decrypt )  ((lambda (p )  ((lambda (q )  ((lambda (n )  ((lambda (e )  ((lambda (d )  ((lambda (plaintext )  ((lambda (ciphertext )  ((lambda (decrypted-ciphertext )  ((lambda (_$$1 )  ((lambda (_$$2 )  ((lambda (_$$3 )  ((lambda (_$$4 )  ((lambda (_$$5 )  ((lambda (_$$6 )  ((lambda (_$$7 )  ((lambda (_$$8 )  ((lambda (_$$9 )  ((lambda (_$$10 )  (begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )


State:
State(CmFlat(((lambda (extended-gcd )  ((lambda (modulo-inverse )  ((lambda (totient )  ((lambda (square )  ((lambda (modulo-power )  ((lambda (is-legal-public-exponent? )  ((lambda (private-exponent )  ((lambda (encrypt )  ((lambda (decrypt )  ((lambda (p )  ((lambda (q )  ((lambda (n )  ((lambda (e )  ((lambda (d )  ((lambda (plaintext )  ((lambda (ciphertext )  ((lambda (decrypted-ciphertext )  ((lambda (_$$1 )  ((lambda (_$$2 )  ((lambda (_$$3 )  ((lambda (_$$4 )  ((lambda (_$$5 )  ((lambda (_$$6 )  ((lambda (_$$7 )  ((lambda (_$$8 )  ((lambda (_$$9 )  ((lambda (_$$10 )  (begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})))

State:
State(CmFlat(((lambda (modulo-inverse )  ((lambda (totient )  ((lambda (square )  ((lambda (modulo-power )  ((lambda (is-legal-public-exponent? )  ((lambda (private-exponent )  ((lambda (encrypt )  ((lambda (decrypt )  ((lambda (p )  ((lambda (q )  ((lambda (n )  ((lambda (e )  ((lambda (d )  ((lambda (plaintext )  ((lambda (ciphertext )  ((lambda (decrypted-ciphertext )  ((lambda (_$$1 )  ((lambda (_$$2 )  ((lambda (_$$3 )  ((lambda (_$$4 )  ((lambda (_$$5 )  ((lambda (_$$6 )  ((lambda (_$$7 )  ((lambda (_$$8 )  ((lambda (_$$9 )  ((lambda (_$$10 )  (begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda (totient )  ((lambda (square )  ((lambda (modulo-power )  ((lambda (is-legal-public-exponent? )  ((lambda (private-exponent )  ((lambda (encrypt )  ((lambda (decrypt )  ((lambda (p )  ((lambda (q )  ((lambda (n )  ((lambda (e )  ((lambda (d )  ((lambda (plaintext )  ((lambda (ciphertext )  ((lambda (decrypted-ciphertext )  ((lambda (_$$1 )  ((lambda (_$$2 )  ((lambda (_$$3 )  ((lambda (_$$4 )  ((lambda (_$$5 )  ((lambda (_$$6 )  ((lambda (_$$7 )  ((lambda (_$$8 )  ((lambda (_$$9 )  ((lambda (_$$10 )  (begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda (square )  ((lambda (modulo-power )  ((lambda (is-legal-public-exponent? )  ((lambda (private-exponent )  ((lambda (encrypt )  ((lambda (decrypt )  ((lambda (p )  ((lambda (q )  ((lambda (n )  ((lambda (e )  ((lambda (d )  ((lambda (plaintext )  ((lambda (ciphertext )  ((lambda (decrypted-ciphertext )  ((lambda (_$$1 )  ((lambda (_$$2 )  ((lambda (_$$3 )  ((lambda (_$$4 )  ((lambda (_$$5 )  ((lambda (_$$6 )  ((lambda (_$$7 )  ((lambda (_$$8 )  ((lambda (_$$9 )  ((lambda (_$$10 )  (begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda (modulo-power )  ((lambda (is-legal-public-exponent? )  ((lambda (private-exponent )  ((lambda (encrypt )  ((lambda (decrypt )  ((lambda (p )  ((lambda (q )  ((lambda (n )  ((lambda (e )  ((lambda (d )  ((lambda (plaintext )  ((lambda (ciphertext )  ((lambda (decrypted-ciphertext )  ((lambda (_$$1 )  ((lambda (_$$2 )  ((lambda (_$$3 )  ((lambda (_$$4 )  ((lambda (_$$5 )  ((lambda (_$$6 )  ((lambda (_$$7 )  ((lambda (_$$8 )  ((lambda (_$$9 )  ((lambda (_$$10 )  (begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda (is-legal-public-exponent? )  ((lambda (private-exponent )  ((lambda (encrypt )  ((lambda (decrypt )  ((lambda (p )  ((lambda (q )  ((lambda (n )  ((lambda (e )  ((lambda (d )  ((lambda (plaintext )  ((lambda (ciphertext )  ((lambda (decrypted-ciphertext )  ((lambda (_$$1 )  ((lambda (_$$2 )  ((lambda (_$$3 )  ((lambda (_$$4 )  ((lambda (_$$5 )  ((lambda (_$$6 )  ((lambda (_$$7 )  ((lambda (_$$8 )  ((lambda (_$$9 )  ((lambda (_$$10 )  (begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda (private-exponent )  ((lambda (encrypt )  ((lambda (decrypt )  ((lambda (p )  ((lambda (q )  ((lambda (n )  ((lambda (e )  ((lambda (d )  ((lambda (plaintext )  ((lambda (ciphertext )  ((lambda (decrypted-ciphertext )  ((lambda (_$$1 )  ((lambda (_$$2 )  ((lambda (_$$3 )  ((lambda (_$$4 )  ((lambda (_$$5 )  ((lambda (_$$6 )  ((lambda (_$$7 )  ((lambda (_$$8 )  ((lambda (_$$9 )  ((lambda (_$$10 )  (begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda (encrypt )  ((lambda (decrypt )  ((lambda (p )  ((lambda (q )  ((lambda (n )  ((lambda (e )  ((lambda (d )  ((lambda (plaintext )  ((lambda (ciphertext )  ((lambda (decrypted-ciphertext )  ((lambda (_$$1 )  ((lambda (_$$2 )  ((lambda (_$$3 )  ((lambda (_$$4 )  ((lambda (_$$5 )  ((lambda (_$$6 )  ((lambda (_$$7 )  ((lambda (_$$8 )  ((lambda (_$$9 )  ((lambda (_$$10 )  (begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda (decrypt )  ((lambda (p )  ((lambda (q )  ((lambda (n )  ((lambda (e )  ((lambda (d )  ((lambda (plaintext )  ((lambda (ciphertext )  ((lambda (decrypted-ciphertext )  ((lambda (_$$1 )  ((lambda (_$$2 )  ((lambda (_$$3 )  ((lambda (_$$4 )  ((lambda (_$$5 )  ((lambda (_$$6 )  ((lambda (_$$7 )  ((lambda (_$$8 )  ((lambda (_$$9 )  ((lambda (_$$10 )  (begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda (p )  ((lambda (q )  ((lambda (n )  ((lambda (e )  ((lambda (d )  ((lambda (plaintext )  ((lambda (ciphertext )  ((lambda (decrypted-ciphertext )  ((lambda (_$$1 )  ((lambda (_$$2 )  ((lambda (_$$3 )  ((lambda (_$$4 )  ((lambda (_$$5 )  ((lambda (_$$6 )  ((lambda (_$$7 )  ((lambda (_$$8 )  ((lambda (_$$9 )  ((lambda (_$$10 )  (begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda (q )  ((lambda (n )  ((lambda (e )  ((lambda (d )  ((lambda (plaintext )  ((lambda (ciphertext )  ((lambda (decrypted-ciphertext )  ((lambda (_$$1 )  ((lambda (_$$2 )  ((lambda (_$$3 )  ((lambda (_$$4 )  ((lambda (_$$5 )  ((lambda (_$$6 )  ((lambda (_$$7 )  ((lambda (_$$8 )  ((lambda (_$$9 )  ((lambda (_$$10 )  (begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda (n )  ((lambda (e )  ((lambda (d )  ((lambda (plaintext )  ((lambda (ciphertext )  ((lambda (decrypted-ciphertext )  ((lambda (_$$1 )  ((lambda (_$$2 )  ((lambda (_$$3 )  ((lambda (_$$4 )  ((lambda (_$$5 )  ((lambda (_$$6 )  ((lambda (_$$7 )  ((lambda (_$$8 )  ((lambda (_$$9 )  ((lambda (_$$10 )  (begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda (e )  ((lambda (d )  ((lambda (plaintext )  ((lambda (ciphertext )  ((lambda (decrypted-ciphertext )  ((lambda (_$$1 )  ((lambda (_$$2 )  ((lambda (_$$3 )  ((lambda (_$$4 )  ((lambda (_$$5 )  ((lambda (_$$6 )  ((lambda (_$$7 )  ((lambda (_$$8 )  ((lambda (_$$9 )  ((lambda (_$$10 )  (begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda (d )  ((lambda (plaintext )  ((lambda (ciphertext )  ((lambda (decrypted-ciphertext )  ((lambda (_$$1 )  ((lambda (_$$2 )  ((lambda (_$$3 )  ((lambda (_$$4 )  ((lambda (_$$5 )  ((lambda (_$$6 )  ((lambda (_$$7 )  ((lambda (_$$8 )  ((lambda (_$$9 )  ((lambda (_$$10 )  (begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda (plaintext )  ((lambda (ciphertext )  ((lambda (decrypted-ciphertext )  ((lambda (_$$1 )  ((lambda (_$$2 )  ((lambda (_$$3 )  ((lambda (_$$4 )  ((lambda (_$$5 )  ((lambda (_$$6 )  ((lambda (_$$7 )  ((lambda (_$$8 )  ((lambda (_$$9 )  ((lambda (_$$10 )  (begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda (ciphertext )  ((lambda (decrypted-ciphertext )  ((lambda (_$$1 )  ((lambda (_$$2 )  ((lambda (_$$3 )  ((lambda (_$$4 )  ((lambda (_$$5 )  ((lambda (_$$6 )  ((lambda (_$$7 )  ((lambda (_$$8 )  ((lambda (_$$9 )  ((lambda (_$$10 )  (begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda (decrypted-ciphertext )  ((lambda (_$$1 )  ((lambda (_$$2 )  ((lambda (_$$3 )  ((lambda (_$$4 )  ((lambda (_$$5 )  ((lambda (_$$6 )  ((lambda (_$$7 )  ((lambda (_$$8 )  ((lambda (_$$9 )  ((lambda (_$$10 )  (begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda (_$$1 )  ((lambda (_$$2 )  ((lambda (_$$3 )  ((lambda (_$$4 )  ((lambda (_$$5 )  ((lambda (_$$6 )  ((lambda (_$$7 )  ((lambda (_$$8 )  ((lambda (_$$9 )  ((lambda (_$$10 )  (begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda (_$$2 )  ((lambda (_$$3 )  ((lambda (_$$4 )  ((lambda (_$$5 )  ((lambda (_$$6 )  ((lambda (_$$7 )  ((lambda (_$$8 )  ((lambda (_$$9 )  ((lambda (_$$10 )  (begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda (_$$3 )  ((lambda (_$$4 )  ((lambda (_$$5 )  ((lambda (_$$6 )  ((lambda (_$$7 )  ((lambda (_$$8 )  ((lambda (_$$9 )  ((lambda (_$$10 )  (begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda (_$$4 )  ((lambda (_$$5 )  ((lambda (_$$6 )  ((lambda (_$$7 )  ((lambda (_$$8 )  ((lambda (_$$9 )  ((lambda (_$$10 )  (begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda (_$$5 )  ((lambda (_$$6 )  ((lambda (_$$7 )  ((lambda (_$$8 )  ((lambda (_$$9 )  ((lambda (_$$10 )  (begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda (_$$6 )  ((lambda (_$$7 )  ((lambda (_$$8 )  ((lambda (_$$9 )  ((lambda (_$$10 )  (begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda (_$$7 )  ((lambda (_$$8 )  ((lambda (_$$9 )  ((lambda (_$$10 )  (begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) 'undefined )) 'undefined )) 'undefined )) 'undefined ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda (_$$8 )  ((lambda (_$$9 )  ((lambda (_$$10 )  (begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) 'undefined )) 'undefined )) 'undefined ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda (_$$9 )  ((lambda (_$$10 )  (begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) 'undefined )) 'undefined ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda (_$$10 )  (begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) 'undefined ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat((begin  (set! extended-gcd (lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 ))))))))))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) )),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda _$$64  ((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda _$$63  (begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat((begin  (set! modulo-inverse (lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n ))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) )),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda _$$62  ((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda _$$61  (begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat((begin  (set! totient (lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 ))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) )),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{})))

State:
State(CmFlat(((lambda _$$60  ((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat(((lambda _$$59  (begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat((begin  (set! square (lambda (x )  (* x x ))) ((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) )),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat(((lambda _$$58  ((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat(((lambda _$$57  (begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat((begin  (set! modulo-power (lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n )))))))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) )),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat(((lambda _$$56  ((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{Clo((lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n ))))))))),FlatBEnv(List()))})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat(((lambda _$$55  (begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{Clo((lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n ))))))))),FlatBEnv(List()))})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat((begin  (set! is-legal-public-exponent? (lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 ))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) )),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{Clo((lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n ))))))))),FlatBEnv(List()))})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat(((lambda _$$54  ((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 )))))))),FlatBEnv(List()))})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{Clo((lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n ))))))))),FlatBEnv(List()))})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat(((lambda _$$53  (begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 )))))))),FlatBEnv(List()))})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{Clo((lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n ))))))))),FlatBEnv(List()))})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat((begin  (set! private-exponent (lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) )),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 )))))))),FlatBEnv(List()))})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{Clo((lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n ))))))))),FlatBEnv(List()))})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat(((lambda _$$52  ((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 )))))))),FlatBEnv(List()))})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{Clo((lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n ))))))))),FlatBEnv(List()))})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." )))),FlatBEnv(List()))})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat(((lambda _$$51  (begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 )))))))),FlatBEnv(List()))})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{Clo((lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n ))))))))),FlatBEnv(List()))})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." )))),FlatBEnv(List()))})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat((begin  (set! encrypt (lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n ))))) ((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) )),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 )))))))),FlatBEnv(List()))})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{Clo((lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n ))))))))),FlatBEnv(List()))})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." )))),FlatBEnv(List()))})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat(((lambda _$$50  ((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{Clo((lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n )))),FlatBEnv(List()))})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 )))))))),FlatBEnv(List()))})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{Clo((lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n ))))))))),FlatBEnv(List()))})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." )))),FlatBEnv(List()))})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat(((lambda _$$49  (begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{Clo((lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n )))),FlatBEnv(List()))})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 )))))))),FlatBEnv(List()))})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{Clo((lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n ))))))))),FlatBEnv(List()))})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." )))),FlatBEnv(List()))})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat((begin  (set! decrypt (lambda (c d n )  (modulo-power c d n ))) ((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) )),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{Clo((lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n )))),FlatBEnv(List()))})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 )))))))),FlatBEnv(List()))})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{Clo((lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n ))))))))),FlatBEnv(List()))})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." )))),FlatBEnv(List()))})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat(((lambda _$$48  ((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{Clo((lambda (c d n )  (modulo-power c d n )),FlatBEnv(List()))})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{Clo((lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n )))),FlatBEnv(List()))})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 )))))))),FlatBEnv(List()))})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{Clo((lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n ))))))))),FlatBEnv(List()))})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." )))),FlatBEnv(List()))})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat(((lambda _$$47  (begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))) (void) ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{Clo((lambda (c d n )  (modulo-power c d n )),FlatBEnv(List()))})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{Clo((lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n )))),FlatBEnv(List()))})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 )))))))),FlatBEnv(List()))})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{Clo((lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n ))))))))),FlatBEnv(List()))})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." )))),FlatBEnv(List()))})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat((begin  (set! p 41) ((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) )),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{Clo((lambda (c d n )  (modulo-power c d n )),FlatBEnv(List()))})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{Clo((lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n )))),FlatBEnv(List()))})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 )))))))),FlatBEnv(List()))})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{Clo((lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n ))))))))),FlatBEnv(List()))})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." )))),FlatBEnv(List()))})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat(((lambda _$$46  ((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{Clo((lambda (c d n )  (modulo-power c d n )),FlatBEnv(List()))})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{Clo((lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n )))),FlatBEnv(List()))})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 )))))))),FlatBEnv(List()))})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{Clo((lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n ))))))))),FlatBEnv(List()))})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." )))),FlatBEnv(List()))})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat(((lambda _$$45  (begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{Clo((lambda (c d n )  (modulo-power c d n )),FlatBEnv(List()))})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{Clo((lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n )))),FlatBEnv(List()))})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 )))))))),FlatBEnv(List()))})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{Clo((lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n ))))))))),FlatBEnv(List()))})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." )))),FlatBEnv(List()))})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat((begin  (set! q 47) ((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) )),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{Clo((lambda (c d n )  (modulo-power c d n )),FlatBEnv(List()))})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{Clo((lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n )))),FlatBEnv(List()))})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 )))))))),FlatBEnv(List()))})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{Clo((lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n ))))))))),FlatBEnv(List()))})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." )))),FlatBEnv(List()))})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat(((lambda _$$44  ((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{Clo((lambda (c d n )  (modulo-power c d n )),FlatBEnv(List()))})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{Clo((lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n )))),FlatBEnv(List()))})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 )))))))),FlatBEnv(List()))})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{Clo((lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n ))))))))),FlatBEnv(List()))})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." )))),FlatBEnv(List()))})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat(((lambda _$$43  (* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{Clo((lambda (c d n )  (modulo-power c d n )),FlatBEnv(List()))})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{Clo((lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n )))),FlatBEnv(List()))})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 )))))))),FlatBEnv(List()))})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{Clo((lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n ))))))))),FlatBEnv(List()))})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." )))),FlatBEnv(List()))})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat((* p q #:cc (lambda ($tmp$$17 )  (begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) )))),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{Clo((lambda (c d n )  (modulo-power c d n )),FlatBEnv(List()))})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{Clo((lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n )))),FlatBEnv(List()))})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 )))))))),FlatBEnv(List()))})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{Clo((lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n ))))))))),FlatBEnv(List()))})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." )))),FlatBEnv(List()))})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat((begin  (set! n $tmp$$17) ((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) )),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr($tmp$$17,FlatBEnv(List())),{})
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{Clo((lambda (c d n )  (modulo-power c d n )),FlatBEnv(List()))})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{Clo((lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n )))),FlatBEnv(List()))})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 )))))))),FlatBEnv(List()))})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{Clo((lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n ))))))))),FlatBEnv(List()))})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." )))),FlatBEnv(List()))})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat(((lambda _$$42  ((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr($tmp$$17,FlatBEnv(List())),{})
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{Clo((lambda (c d n )  (modulo-power c d n )),FlatBEnv(List()))})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{Clo((lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n )))),FlatBEnv(List()))})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 )))))))),FlatBEnv(List()))})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{Clo((lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n ))))))))),FlatBEnv(List()))})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." )))),FlatBEnv(List()))})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat(((lambda _$$41  (begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ))) (void) ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr($tmp$$17,FlatBEnv(List())),{})
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{Clo((lambda (c d n )  (modulo-power c d n )),FlatBEnv(List()))})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{Clo((lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n )))),FlatBEnv(List()))})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 )))))))),FlatBEnv(List()))})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{Clo((lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n ))))))))),FlatBEnv(List()))})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." )))),FlatBEnv(List()))})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat((begin  (set! e 7) ((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) )),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr($tmp$$17,FlatBEnv(List())),{})
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{Clo((lambda (c d n )  (modulo-power c d n )),FlatBEnv(List()))})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{Clo((lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n )))),FlatBEnv(List()))})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 )))))))),FlatBEnv(List()))})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{Clo((lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n ))))))))),FlatBEnv(List()))})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." )))),FlatBEnv(List()))})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat(((lambda _$$40  ((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) )) (void) ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr($tmp$$17,FlatBEnv(List())),{})
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{Clo((lambda (c d n )  (modulo-power c d n )),FlatBEnv(List()))})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{Clo((lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n )))),FlatBEnv(List()))})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 )))))))),FlatBEnv(List()))})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{Clo((lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n ))))))))),FlatBEnv(List()))})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." )))),FlatBEnv(List()))})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat(((lambda _$$39  (private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) ))))) (void) ),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr($tmp$$17,FlatBEnv(List())),{})
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{Clo((lambda (c d n )  (modulo-power c d n )),FlatBEnv(List()))})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{Clo((lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n )))),FlatBEnv(List()))})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 )))))))),FlatBEnv(List()))})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{Clo((lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n ))))))))),FlatBEnv(List()))})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." )))),FlatBEnv(List()))})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

State:
State(CmFlat((private-exponent e p q #:cc (lambda ($tmp$$16 )  (begin  (set! d $tmp$$16) ((lambda _$$38  ((lambda _$$37  (begin  (set! plaintext 42) ((lambda _$$36  ((lambda _$$35  (encrypt plaintext e n #:cc (lambda ($tmp$$15 )  (begin  (set! ciphertext $tmp$$15) ((lambda _$$34  ((lambda _$$33  (decrypt ciphertext d n #:cc (lambda ($tmp$$14 )  (begin  (set! decrypted-ciphertext $tmp$$14) ((lambda _$$32  ((lambda _$$31  (display "The plaintext is:            " #:cc (lambda ($tmp$$13 )  (begin  (set! _$$1 $tmp$$13) ((lambda _$$30  ((lambda _$$29  (display plaintext #:cc (lambda ($tmp$$12 )  (begin  (set! _$$2 $tmp$$12) ((lambda _$$28  ((lambda _$$27  (newline  #:cc (lambda ($tmp$$11 )  (begin  (set! _$$3 $tmp$$11) ((lambda _$$26  ((lambda _$$25  (display "The ciphertext is:           " #:cc (lambda ($tmp$$10 )  (begin  (set! _$$4 $tmp$$10) ((lambda _$$24  ((lambda _$$23  (display ciphertext #:cc (lambda ($tmp$$9 )  (begin  (set! _$$5 $tmp$$9) ((lambda _$$22  ((lambda _$$21  (newline  #:cc (lambda ($tmp$$8 )  (begin  (set! _$$6 $tmp$$8) ((lambda _$$20  ((lambda _$$19  (display "The decrypted ciphertext is: " #:cc (lambda ($tmp$$7 )  (begin  (set! _$$7 $tmp$$7) ((lambda _$$18  ((lambda _$$17  (display decrypted-ciphertext #:cc (lambda ($tmp$$6 )  (begin  (set! _$$8 $tmp$$6) ((lambda _$$16  ((lambda _$$15  (newline  #:cc (lambda ($tmp$$5 )  (begin  (set! _$$9 $tmp$$5) ((lambda _$$14  ((lambda _$$13  (= plaintext decrypted-ciphertext #:cc (lambda ($tmp$$1 )  (not $tmp$$1 #:cc (lambda ($tmp$$2 )  (error "RSA fail!" #:cc (lambda ($tmp$$3 )  (if $tmp$$2 $tmp$$3 #:cc (lambda ($tmp$$4 )  (begin  (set! _$$10 $tmp$$4) ((lambda _$$12  ((lambda _$$11  ((lambda (answer )  answer) _$$10 )) (void) )) (void) ))))))))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))))) (void) )) (void) ))) (void) )) (void) )))),FlatBEnv(List()),UniTime),StoreSharp(
 (FlatAddr($tmp$$17,FlatBEnv(List())),{})
 (FlatAddr(*,FlatBEnv(List())),{PrimValue(*)})
 (FlatAddr(_$$1,FlatBEnv(List())),{})
 (FlatAddr(_$$2,FlatBEnv(List())),{})
 (FlatAddr(_$$3,FlatBEnv(List())),{})
 (FlatAddr(_$$4,FlatBEnv(List())),{})
 (FlatAddr(_$$5,FlatBEnv(List())),{})
 (FlatAddr(_$$6,FlatBEnv(List())),{})
 (FlatAddr(_$$7,FlatBEnv(List())),{})
 (FlatAddr(_$$8,FlatBEnv(List())),{})
 (FlatAddr(_$$9,FlatBEnv(List())),{})
 (FlatAddr(_$$10,FlatBEnv(List())),{})
 (FlatAddr(ciphertext,FlatBEnv(List())),{})
 (FlatAddr(d,FlatBEnv(List())),{})
 (FlatAddr(decrypt,FlatBEnv(List())),{Clo((lambda (c d n )  (modulo-power c d n )),FlatBEnv(List()))})
 (FlatAddr(decrypted-ciphertext,FlatBEnv(List())),{})
 (FlatAddr(e,FlatBEnv(List())),{})
 (FlatAddr(encrypt,FlatBEnv(List())),{Clo((lambda (m e n )  (let (($tmp$$18 (> m n )))  (if $tmp$$18 (error "The modulus is too small to encrypt the message." ) (modulo-power m e n )))),FlatBEnv(List()))})
 (FlatAddr(extended-gcd,FlatBEnv(List())),{Clo((lambda (a b )  (let (($tmp$$39 (modulo a b )))  (let (($tmp$$40 (= $tmp$$39 0 )))  (if $tmp$$40 (cons 0 1 ) (let (($tmp$$41 (modulo a b )))  (let ((x:y (extended-gcd b $tmp$$41 )))  (let ((x (car x:y )))  (let ((y (cdr x:y )))  (let (($tmp$$42 (quotient a b )))  (let (($tmp$$43 (* y $tmp$$42 )))  (let (($tmp$$44 (- x $tmp$$43 )))  (cons y $tmp$$44 )))))))))))),FlatBEnv(List()))})
 (FlatAddr(is-legal-public-exponent?,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$21 (< 1 e )))  (let (($tmp$$22 (totient p q )))  (let (($tmp$$23 (< e $tmp$$22 )))  (let (($tmp$$24 (totient p q )))  (let (($tmp$$25 (gcd e $tmp$$24 )))  (let (($tmp$$26 (= 1 $tmp$$25 )))  (and $tmp$$21 $tmp$$23 $tmp$$26 )))))))),FlatBEnv(List()))})
 (FlatAddr(modulo-inverse,FlatBEnv(List())),{Clo((lambda (a n )  (let (($tmp$$37 (extended-gcd a n )))  (let (($tmp$$38 (car $tmp$$37 )))  (modulo $tmp$$38 n )))),FlatBEnv(List()))})
 (FlatAddr(modulo-power,FlatBEnv(List())),{Clo((lambda (base exp n )  (let (($tmp$$27 (= exp 0 )))  (if $tmp$$27 1 (let (($tmp$$28 (odd? exp )))  (if $tmp$$28 (let (($tmp$$29 (- exp 1 )))  (let (($tmp$$30 (modulo-power base $tmp$$29 n )))  (let (($tmp$$31 (* base $tmp$$30 )))  (modulo $tmp$$31 n )))) (let (($tmp$$32 (/ exp 2 )))  (let (($tmp$$33 (modulo-power base $tmp$$32 n )))  (let (($tmp$$34 (square $tmp$$33 )))  (modulo $tmp$$34 n ))))))))),FlatBEnv(List()))})
 (FlatAddr(n,FlatBEnv(List())),{})
 (FlatAddr(p,FlatBEnv(List())),{})
 (FlatAddr(plaintext,FlatBEnv(List())),{})
 (FlatAddr(private-exponent,FlatBEnv(List())),{Clo((lambda (e p q )  (let (($tmp$$19 (is-legal-public-exponent? e p q )))  (if $tmp$$19 (let (($tmp$$20 (totient p q )))  (modulo-inverse e $tmp$$20 )) (error "Not a legal public exponent for that modulus." )))),FlatBEnv(List()))})
 (FlatAddr(q,FlatBEnv(List())),{})
 (FlatAddr(square,FlatBEnv(List())),{Clo((lambda (x )  (* x x )),FlatBEnv(List()))})
 (FlatAddr(totient,FlatBEnv(List())),{Clo((lambda (p q )  (let (($tmp$$35 (- p 1 )))  (let (($tmp$$36 (- q 1 )))  (* $tmp$$35 $tmp$$36 )))),FlatBEnv(List()))})))

