Input program:
(define cadr (lambda (p )  (car (cdr p ) )))

(define cddr (lambda (p )  (cdr (cdr p ) )))

(define cdddr (lambda (p )  (cdr (cdr (cdr p ) ) )))

(define caadr (lambda (p )  (car (car (cdr p ) ) )))

(define caddr (lambda (p )  (car (cdr (cdr p ) ) )))

(define cadar (lambda (p )  (car (cdr (car p ) ) )))

(define cadddr (lambda (p )  (car (cdr (cdr (cdr p ) ) ) )))

(define map (lambda (f lst )  (if (pair? lst ) (cons (f (car lst ) ) (map f (cdr lst ) ) ) (quote ()))))

(define for-each (lambda (f lst )  (begin  (if (pair? lst ) (cons (f (car lst ) ) (map f (cdr lst ) ) ) (quote ())) (void  ))))

(define append (lambda (lst1 lst2 )  (if (not (pair? lst1 ) ) lst2 (cons (car lst1 ) (append (cdr lst1 ) lst2 ) ))))

(define string->list (lambda (s ) (define f (lambda (i )  (if (< i (string-length s ) ) (cons (string-ref s i ) (f (+ i 1 ) ) ) (quote ())))) (f 0 )))

(define apply (lambda (f l )  (let ((len (length l )))  Cond(List(TestCondClause((= len 0 ),List((f  ))), TestCondClause((= len 1 ),List((f (car l ) ))), TestCondClause((= len 2 ),List((f (car l ) (cadr l ) ))), TestCondClause((= len 3 ),List((f (car l ) (cadr l ) (caddr l ) ))), TestCondClause((= len 4 ),List((f (car l ) (cadr l ) (caddr l ) (cadddr l ) ))))))))

(define assv (lambda (x f )  (if (pair? f ) (if (eqv? (car (car f ) ) x ) (car f ) (assv x (cdr f ) )) #f)))

(define assq (lambda (x f )  (if (pair? f ) (if (eq? (car (car f ) ) x ) (car f ) (assv x (cdr f ) )) #f)))

(define gensym-count 0)

(define gensym (lambda (name )  (begin  (set! gensym-count (+ gensym-count 1 )) (string->symbol (string-append (if (symbol? name ) (symbol->string name ) name) "$" (number->string gensym-count ) ) ))))

(define three-d-tagged-list? (lambda (tag lst )  And(List((pair? lst ), Or(List((eq? (car lst ) tag ), And(List((procedure? (car lst ) ), (equal? ((car lst )  ) (initial tag ) )))))))))

(define tagged-list? (lambda (tag lst )  And(List((pair? lst ), (eq? (car lst ) tag )))))

(define singlet? (lambda (list )  And(List((pair? list ), (null? (cdr list ) )))))

(define partition-k (lambda (pred list k )  (if (not (pair? list ) ) (k (quote ()) (quote ()) ) (partition-k pred (cdr list ) (lambda (trues falses )  (if (pred (car list ) ) (k (cons (car list ) trues ) falses ) (k trues (cons (car list ) falses ) ))) ))))

(define unzip-amap-k (lambda (amap k )  (if (not (pair? amap ) ) (k (quote ()) (quote ()) ) (unzip-amap-k (cdr amap ) (lambda (xs ys )  (k (cons (car (car amap ) ) xs ) (cons (cadr (car amap ) ) ys ) )) ))))

(define void (lambda ( )  (if #f #t (void))))

(define define? (lambda (s-exp )  (tagged-list? (quote define) s-exp )))

(define define-var? (lambda (s-exp )  And(List((define? s-exp ), (symbol? (cadr s-exp ) )))))

(define define-fun? (lambda (s-exp )  And(List((define? s-exp ), (pair? (cadr s-exp ) )))))

(define define->var (lambda (s-exp )  Cond(List(TestCondClause((define-var? s-exp ),List((cadr s-exp ))), TestCondClause((define-fun? s-exp ),List((caadr s-exp ))), ElseCondClause(List((error "unknown define!" )))))))

(define define->exp (lambda (s-exp )  Cond(List(TestCondClause((define-var? s-exp ),List((caddr s-exp ))), TestCondClause((define-fun? s-exp ),List((cons three-d-lambda (cons (cdadr s-exp ) (cddr s-exp ) ) )))))))

(define if? (lambda (s-exp )  (three-d-tagged-list? (quote if) s-exp )))

(define if-single? (lambda (s-exp )  And(List((if? s-exp ), (null? (cdddr s-exp ) )))))

(define if->cond (lambda (s-exp )  (cadr s-exp )))

(define if->true (lambda (s-exp )  (caddr s-exp )))

(define if->false (lambda (s-exp )  (cadddr s-exp )))

(define quote? (lambda (s-exp )  (three-d-tagged-list? (quote quote) s-exp )))

(define quote->text (lambda (s-exp )  (cadr s-exp )))

(define lambda? (lambda (s-exp )  (three-d-tagged-list? (quote lambda) s-exp )))

(define lambda-multi? (lambda (s-exp )  And(List((lambda? s-exp ), (symbol? (cadr s-exp ) )))))

(define lambda->formals (lambda (s-exp )  (cadr s-exp )))

(define lambda->body (lambda (s-exp )  (cddr s-exp )))

(define lambda->body-as-exp (lambda (s-exp )  (make-begin (cddr s-exp ) )))

(define begin? (lambda (s-exp )  (three-d-tagged-list? (quote begin) s-exp )))

(define begin->body (lambda (s-exp )  (cdr s-exp )))

(define make-begin (lambda (exps )  Cond(List(TestCondClause((singlet? exps ),List((car exps ))), ElseCondClause(List((cons three-d-begin exps )))))))

(define app? (lambda (s-exp )  (pair? s-exp )))

(define app->fun (lambda (s-exp )  (car s-exp )))

(define app->args (lambda (s-exp )  (cdr s-exp )))

(define binding->var (lambda (binding )  (car binding )))

(define binding->exp (lambda (binding )  (cadr binding )))

(define letrec? (lambda (s-exp )  (three-d-tagged-list? (quote letrec) s-exp )))

(define letrec->bindings (lambda (s-exp )  (cadr s-exp )))

(define letrec->body (lambda (s-exp )  (cddr s-exp )))

(define letrec->body-as-exp (lambda (s-exp )  (make-begin (letrec->body s-exp ) )))

(define let? (lambda (s-exp )  (three-d-tagged-list? (quote let) s-exp )))

(define let->bindings (lambda (s-exp )  (cadr s-exp )))

(define let->body (lambda (s-exp )  (cddr s-exp )))

(define let->body-as-exp (lambda (s-exp )  (make-begin (let->body s-exp ) )))

(define let*? (lambda (s-exp )  (three-d-tagged-list? (quote let*) s-exp )))

(define let*->bindings (lambda (s-exp )  (cadr s-exp )))

(define let*->body (lambda (s-exp )  (cddr s-exp )))

(define let*->body-as-exp (lambda (s-exp )  (make-begin (let*->body s-exp ) )))

(define or? (lambda (s-exp )  (three-d-tagged-list? (quote or) s-exp )))

(define or->exps (lambda (s-exp )  (cdr s-exp )))

(define make-or (lambda (exps )  Cond(List(TestCondClause((null? exps ),List(#f)), TestCondClause((singlet? exps ),List((car exps ))), ElseCondClause(List((cons (quote or) exps )))))))

(define and? (lambda (s-exp )  (three-d-tagged-list? (quote and) s-exp )))

(define and->exps (lambda (s-exp )  (cdr s-exp )))

(define make-and (lambda (exps )  Cond(List(TestCondClause((null? exps ),List(#t)), TestCondClause((singlet? exps ),List((car exps ))), ElseCondClause(List((cons (quote and) exps )))))))

(define cond? (lambda (s-exp )  (three-d-tagged-list? (quote cond) s-exp )))

(define cond->clauses (lambda (s-exp )  (cdr s-exp )))

(define arrow-clause? (lambda (clause )  And(List((pair? clause ), (pair? (cdr clause ) ), (eq? (cadr clause ) (quote =>) )))))

(define else-clause? (lambda (clause )  (three-d-tagged-list? (quote else) clause )))

(define cond-clause->exp (lambda (clause )  Cond(List(TestCondClause((singlet? clause ),List((car clause ))), TestCondClause((else-clause? clause ),List((cadr clause ))), TestCondClause((arrow-clause? clause ),List((caddr clause ))), ElseCondClause(List((make-begin (cdr clause ) )))))))

(define cond-clause->test (lambda (clause )  Cond(List(TestCondClause((singlet? clause ),List((car clause ))), TestCondClause((else-clause? clause ),List(#t)), TestCondClause((arrow-clause? clause ),List((car clause ))), ElseCondClause(List((car clause )))))))

(define set!? (lambda (s-exp )  (three-d-tagged-list? (quote set!) s-exp )))

(define set!->var (lambda (s-exp )  (cadr s-exp )))

(define set!->exp (lambda (s-exp )  (caddr s-exp )))

(define macro? (lambda (s-exp )  (three-d-tagged-list? (quote macro) s-exp )))

(define macro->proc (lambda (s-exp )  (cadr s-exp )))

(define syntax-primitive? (lambda (value )  (three-d-tagged-list? (quote syntax-primitive) value )))

(define syntax-primitive->eval (lambda (value )  (cadr value )))

(define def->binding (lambda (def )  (list (define->var def ) (define->exp def ) )))

(define body->letrec (lambda (decs )  (partition-k define? decs (lambda (defs exps )  (if (null? defs ) (make-begin exps ) (let ((bindings (map def->binding defs )))  (list three-d-letrec bindings (make-begin exps ) )))) )))

(define letrec->lets+sets (lambda (exp )  (if (not (letrec? exp ) ) exp (let ((bindings (map (lambda (binding )  (list (binding->var binding ) #f )) (letrec->bindings exp ) )) (sets (map (lambda (binding )  (list three-d-set! (binding->var binding ) (binding->exp binding ) )) (letrec->bindings exp ) )))  (list three-d-let bindings (make-begin (append sets (letrec->body exp ) ) ) )))))

(define cond->if (lambda (cond-exp )  (if (not (cond? cond-exp ) ) cond-exp (cond-clauses->if (cond->clauses cond-exp ) ))))

(define cond-clauses->if (lambda (clauses )  (if (null? clauses ) (cons (quote void) (quote ()) ) (let ((clause (car clauses )))  Cond(List(TestCondClause((singlet? clause ),List((make-or (cons clause (cond-clauses->if (cdr clauses ) ) ) ))), TestCondClause((else-clause? clause ),List((cond-clause->exp clause ))), ElseCondClause(List((list three-d-if (cond-clause->test clause ) (cond-clause->exp clause ) (cond-clauses->if (cdr clauses ) ) )))))))))

(define and->if (lambda (exp )  (if (not (and? exp ) ) exp (let ((exps (and->exps exp )))  Cond(List(TestCondClause((null? exps ),List(#t)), TestCondClause((singlet? exps ),List((car exps ))), ElseCondClause(List((list three-d-if (car exps ) (and->if (cons (quote and) (cdr exps ) ) ) #f )))))))))

(define or->if (lambda (exp )  (if (not (or? exp ) ) exp (let ((exps (or->exps exp )))  Cond(List(TestCondClause((null? exps ),List(#f)), TestCondClause((singlet? exps ),List((car exps ))), ElseCondClause(List((let (($tmp (gensym "or-tmp" )))  (list three-d-let (list (list $tmp (car exps ) ) ) (list three-d-if $tmp $tmp (or->if (cons three-d-or (cdr exps ) ) ) ) ))))))))))

(define let*->let (lambda (exp )  (if (not (let*? exp ) ) exp (let*-bindings->let (let*->bindings exp ) (let*->body exp ) ))))

(define let*-bindings->let (lambda (bindings body )  Cond(List(TestCondClause((singlet? bindings ),List((cons three-d-let (cons (list (car bindings ) ) body ) ))), TestCondClause((null? bindings ),List((make-begin body ))), ElseCondClause(List((cons three-d-let (cons (list (car bindings ) ) (list (let*-bindings->let (cdr bindings ) body ) ) ) )))))))

(define let->app (lambda (exp )  (if (not (let? exp ) ) exp (unzip-amap-k (let->bindings exp ) (lambda (vars exps )  (cons (cons three-d-lambda (cons vars (let->body exp ) ) ) exps )) ))))

(define eval (lambda (exp env )  Cond(List(TestCondClause((symbol? exp ),List((env-lookup env exp ))), TestCondClause((number? exp ),List(exp)), TestCondClause((boolean? exp ),List(exp)), TestCondClause((string? exp ),List(exp)), TestCondClause((procedure? exp ),List((exp  ))), TestCondClause((app? exp ),List((perform-apply (eval (app->fun exp ) env ) exp env )))))))

(define eval-with (lambda (env )  (lambda (exp )  (eval exp env ))))

(define eval* (lambda (exps env )  (map (eval-with env ) exps )))

(define eval-quote (lambda (exp env )  (quote->text exp )))

(define eval-if (lambda (exp env )  (if (if-single? exp ) (if (eval (if->cond exp ) env ) (eval (if->true exp ) env ) (void)) (if (eval (if->cond exp ) env ) (eval (if->true exp ) env ) (eval (if->false exp ) env )))))

(define eval-cond (lambda (exp env )  (eval (cond->if exp ) env )))

(define eval-and (lambda (exp env )  (eval (and->if exp ) env )))

(define eval-or (lambda (exp env )  (eval (or->if exp ) env )))

(define eval-let (lambda (exp env )  (eval (let->app exp ) env )))

(define eval-let* (lambda (exp env )  (eval (let*->let exp ) env )))

(define eval-letrec (lambda (exp env )  (eval (letrec->lets+sets exp ) env )))

(define eval-begin (lambda (exp env )  (let ((simplified (body->letrec (begin->body exp ) )))  Cond(List(TestCondClause((begin? simplified ),List((car (reverse (eval* (begin->body exp ) env ) ) ))), ElseCondClause(List((eval simplified env ))))))))

(define eval-set! (lambda (exp env )  (env-set! env (set!->var exp ) (eval (set!->exp exp ) env ) )))

(define eval-lambda (lambda (exp env )  (let ((formals (lambda->formals exp )))  (lambda args  (if (symbol? formals ) (eval (lambda->body-as-exp exp ) (env-extend env formals args ) ) (eval (lambda->body-as-exp exp ) (env-extend* env formals args ) ))))))

(define eval-macro (lambda (exp env )  (list (quote macro) (eval (macro->proc exp ) env ) )))

(define env-lookup (lambda (env var )  (let ((value (env var #f (quote unused) )))  value)))

(define env-set! (lambda (env var value )  (env var #t value )))

(define env-extend (lambda (env var value )  (lambda (seek-var modify? value! )  (if (eq? var seek-var ) (if modify? (set! value value!) value) (env seek-var modify? value! )))))

(define env-extend* (lambda (env vars values )  (if (pair? vars ) (env-extend* (env-extend env (car vars ) (car values ) ) (cdr vars ) (cdr values ) ) env)))

(define empty-env (lambda (var modify? value! )  (if modify? (begin  (display "error: cannot modify undefined variable: " ) (display var ) (display " with " ) (display value! )) (begin  (display "error: cannot look up undefined variable: " ) (display var ))) (newline  ) (error  )))

(define initial-environment-amap (list (list (quote apply) apply ) (list (quote +) + ) (list (quote not) not ) (list (quote display) display ) (list (quote newline) newline ) (list (quote cons) cons ) (list (quote car) car ) (list (quote cdr) cdr ) (list (quote cadr) cadr ) (list (quote caadr) caadr ) (list (quote cadar) cadar ) (list (quote cddr) cddr ) (list (quote cdddr) cdddr ) (list (quote null?) null? ) (list (quote pair?) pair? ) (list (quote list?) list? ) (list (quote number?) number? ) (list (quote string?) string? ) (list (quote symbol?) symbol? ) (list (quote procedure?) procedure? ) (list (quote eq?) eq? ) (list (quote =) = ) (list (quote gensym) gensym ) (list (quote void) void ) (list (quote quote) (list (quote syntax-primitive) eval-quote ) ) (list (quote if) (list (quote syntax-primitive) eval-if ) ) (list (quote cond) (list (quote syntax-primitive) eval-cond ) ) (list (quote and) (list (quote syntax-primitive) eval-and ) ) (list (quote or) (list (quote syntax-primitive) eval-or ) ) (list (quote let) (list (quote syntax-primitive) eval-let ) ) (list (quote let*) (list (quote syntax-primitive) eval-let* ) ) (list (quote letrec) (list (quote syntax-primitive) eval-letrec ) ) (list (quote begin) (list (quote syntax-primitive) eval-begin ) ) (list (quote set!) (list (quote syntax-primitive) eval-set! ) ) (list (quote lambda) (list (quote syntax-primitive) eval-lambda ) ) (list (quote macro) (list (quote syntax-primitive) eval-macro ) ) ))

(define initial-environment (lambda ( )  (unzip-amap-k initial-environment-amap (lambda (symbols values )  (env-extend* empty-env symbols values )) )))

(define initial (lambda (sym )  (env-lookup (initial-environment  ) sym )))

(define three-d (lambda (value )  (lambda ( )  value)))

(define three-d-quote (three-d (initial (quote quote) ) ))

(define three-d-if (three-d (initial (quote if) ) ))

(define three-d-cond (three-d (initial (quote cond) ) ))

(define three-d-and (three-d (initial (quote and) ) ))

(define three-d-or (three-d (initial (quote or) ) ))

(define three-d-let (three-d (initial (quote let) ) ))

(define three-d-let* (three-d (initial (quote let*) ) ))

(define three-d-letrec (three-d (initial (quote letrec) ) ))

(define three-d-set! (three-d (initial (quote set!) ) ))

(define three-d-lambda (three-d (initial (quote lambda) ) ))

(define three-d-begin (three-d (initial (quote begin) ) ))

(define perform-apply (lambda (fun app-exp env )  (let ((args (app->args app-exp )))  Cond(List(TestCondClause((macro? fun ),List((eval (apply (macro->proc fun ) args ) env ))), TestCondClause((syntax-primitive? fun ),List(((syntax-primitive->eval fun ) app-exp env ))), ElseCondClause(List((let ((arg-values (eval* args env )))  (apply fun arg-values )))))))))

(eval (cons (cons (quote lambda) (cons (cons (quote x) (quote ()) ) (cons (quote x) (quote ()) ) ) ) (cons (quote 10) (quote ()) ) ) (initial-environment  ) )


ANF program:
(let ((cadr 'undefined))  (let ((cddr 'undefined))  (let ((cdddr 'undefined))  (let ((caadr 'undefined))  (let ((caddr 'undefined))  (let ((cadar 'undefined))  (let ((cadddr 'undefined))  (let ((map 'undefined))  (let ((for-each 'undefined))  (let ((append 'undefined))  (let ((string->list 'undefined))  (let ((apply 'undefined))  (let ((assv 'undefined))  (let ((assq 'undefined))  (let ((gensym-count 'undefined))  (let ((gensym 'undefined))  (let ((three-d-tagged-list? 'undefined))  (let ((tagged-list? 'undefined))  (let ((singlet? 'undefined))  (let ((partition-k 'undefined))  (let ((unzip-amap-k 'undefined))  (let ((void 'undefined))  (let ((define? 'undefined))  (let ((define-var? 'undefined))  (let ((define-fun? 'undefined))  (let ((define->var 'undefined))  (let ((define->exp 'undefined))  (let ((if? 'undefined))  (let ((if-single? 'undefined))  (let ((if->cond 'undefined))  (let ((if->true 'undefined))  (let ((if->false 'undefined))  (let ((quote? 'undefined))  (let ((quote->text 'undefined))  (let ((lambda? 'undefined))  (let ((lambda-multi? 'undefined))  (let ((lambda->formals 'undefined))  (let ((lambda->body 'undefined))  (let ((lambda->body-as-exp 'undefined))  (let ((begin? 'undefined))  (let ((begin->body 'undefined))  (let ((make-begin 'undefined))  (let ((app? 'undefined))  (let ((app->fun 'undefined))  (let ((app->args 'undefined))  (let ((binding->var 'undefined))  (let ((binding->exp 'undefined))  (let ((letrec? 'undefined))  (let ((letrec->bindings 'undefined))  (let ((letrec->body 'undefined))  (let ((letrec->body-as-exp 'undefined))  (let ((let? 'undefined))  (let ((let->bindings 'undefined))  (let ((let->body 'undefined))  (let ((let->body-as-exp 'undefined))  (let ((let*? 'undefined))  (let ((let*->bindings 'undefined))  (let ((let*->body 'undefined))  (let ((let*->body-as-exp 'undefined))  (let ((or? 'undefined))  (let ((or->exps 'undefined))  (let ((make-or 'undefined))  (let ((and? 'undefined))  (let ((and->exps 'undefined))  (let ((make-and 'undefined))  (let ((cond? 'undefined))  (let ((cond->clauses 'undefined))  (let ((arrow-clause? 'undefined))  (let ((else-clause? 'undefined))  (let ((cond-clause->exp 'undefined))  (let ((cond-clause->test 'undefined))  (let ((set!? 'undefined))  (let ((set!->var 'undefined))  (let ((set!->exp 'undefined))  (let ((macro? 'undefined))  (let ((macro->proc 'undefined))  (let ((syntax-primitive? 'undefined))  (let ((syntax-primitive->eval 'undefined))  (let ((def->binding 'undefined))  (let ((body->letrec 'undefined))  (let ((letrec->lets+sets 'undefined))  (let ((cond->if 'undefined))  (let ((cond-clauses->if 'undefined))  (let ((and->if 'undefined))  (let ((or->if 'undefined))  (let ((let*->let 'undefined))  (let ((let*-bindings->let 'undefined))  (let ((let->app 'undefined))  (let ((eval 'undefined))  (let ((eval-with 'undefined))  (let ((eval* 'undefined))  (let ((eval-quote 'undefined))  (let ((eval-if 'undefined))  (let ((eval-cond 'undefined))  (let ((eval-and 'undefined))  (let ((eval-or 'undefined))  (let ((eval-let 'undefined))  (let ((eval-let* 'undefined))  (let ((eval-letrec 'undefined))  (let ((eval-begin 'undefined))  (let ((eval-set! 'undefined))  (let ((eval-lambda 'undefined))  (let ((eval-macro 'undefined))  (let ((env-lookup 'undefined))  (let ((env-set! 'undefined))  (let ((env-extend 'undefined))  (let ((env-extend* 'undefined))  (let ((empty-env 'undefined))  (let ((initial-environment-amap 'undefined))  (let ((initial-environment 'undefined))  (let ((initial 'undefined))  (let ((three-d 'undefined))  (let ((three-d-quote 'undefined))  (let ((three-d-if 'undefined))  (let ((three-d-cond 'undefined))  (let ((three-d-and 'undefined))  (let ((three-d-or 'undefined))  (let ((three-d-let 'undefined))  (let ((three-d-let* 'undefined))  (let ((three-d-letrec 'undefined))  (let ((three-d-set! 'undefined))  (let ((three-d-lambda 'undefined))  (let ((three-d-begin 'undefined))  (let ((perform-apply 'undefined))  (let ((_$$1 'undefined))  (begin  (set! cadr (lambda (p )  (let (($tmp$$429 (cdr p )))  (car $tmp$$429 )))) (void)) (begin  (set! cddr (lambda (p )  (let (($tmp$$428 (cdr p )))  (cdr $tmp$$428 )))) (void)) (begin  (set! cdddr (lambda (p )  (let (($tmp$$426 (cdr p )))  (let (($tmp$$427 (cdr $tmp$$426 )))  (cdr $tmp$$427 ))))) (void)) (begin  (set! caadr (lambda (p )  (let (($tmp$$424 (cdr p )))  (let (($tmp$$425 (car $tmp$$424 )))  (car $tmp$$425 ))))) (void)) (begin  (set! caddr (lambda (p )  (let (($tmp$$422 (cdr p )))  (let (($tmp$$423 (cdr $tmp$$422 )))  (car $tmp$$423 ))))) (void)) (begin  (set! cadar (lambda (p )  (let (($tmp$$420 (car p )))  (let (($tmp$$421 (cdr $tmp$$420 )))  (car $tmp$$421 ))))) (void)) (begin  (set! cadddr (lambda (p )  (let (($tmp$$417 (cdr p )))  (let (($tmp$$418 (cdr $tmp$$417 )))  (let (($tmp$$419 (cdr $tmp$$418 )))  (car $tmp$$419 )))))) (void)) (begin  (set! map (lambda (f lst )  (let (($tmp$$412 (pair? lst )))  (if $tmp$$412 (let (($tmp$$413 (car lst )))  (let (($tmp$$414 (f $tmp$$413 )))  (let (($tmp$$415 (cdr lst )))  (let (($tmp$$416 (map f $tmp$$415 )))  (cons $tmp$$414 $tmp$$416 ))))) (quote ()))))) (void)) (begin  (set! for-each (lambda (f lst )  (begin  (let (($tmp$$407 (pair? lst )))  (if $tmp$$407 (let (($tmp$$408 (car lst )))  (let (($tmp$$409 (f $tmp$$408 )))  (let (($tmp$$410 (cdr lst )))  (let (($tmp$$411 (map f $tmp$$410 )))  (cons $tmp$$409 $tmp$$411 ))))) (quote ()))) (void  )))) (void)) (begin  (set! append (lambda (lst1 lst2 )  (let (($tmp$$402 (pair? lst1 )))  (let (($tmp$$403 (not $tmp$$402 )))  (if $tmp$$403 lst2 (let (($tmp$$404 (car lst1 )))  (let (($tmp$$405 (cdr lst1 )))  (let (($tmp$$406 (append $tmp$$405 lst2 )))  (cons $tmp$$404 $tmp$$406 ))))))))) (void)) (begin  (set! string->list (lambda (s )  (let ((f 'undefined))  (begin  (set! f (lambda (i )  (let (($tmp$$397 (string-length s )))  (let (($tmp$$398 (< i $tmp$$397 )))  (if $tmp$$398 (let (($tmp$$399 (string-ref s i )))  (let (($tmp$$400 (+ i 1 )))  (let (($tmp$$401 (f $tmp$$400 )))  (cons $tmp$$399 $tmp$$401 )))) (quote ())))))) (void)) (f 0 )))) (void)) (begin  (set! apply (lambda (f l )  (let ((len (length l )))  (let (($tmp$$382 (= len 0 )))  (if $tmp$$382 (f  ) (let (($tmp$$383 (= len 1 )))  (if $tmp$$383 (let (($tmp$$384 (car l )))  (f $tmp$$384 )) (let (($tmp$$385 (= len 2 )))  (if $tmp$$385 (let (($tmp$$386 (car l )))  (let (($tmp$$387 (cadr l )))  (f $tmp$$386 $tmp$$387 ))) (let (($tmp$$388 (= len 3 )))  (if $tmp$$388 (let (($tmp$$389 (car l )))  (let (($tmp$$390 (cadr l )))  (let (($tmp$$391 (caddr l )))  (f $tmp$$389 $tmp$$390 $tmp$$391 )))) (let (($tmp$$392 (= len 4 )))  (if $tmp$$392 (let (($tmp$$393 (car l )))  (let (($tmp$$394 (cadr l )))  (let (($tmp$$395 (caddr l )))  (let (($tmp$$396 (cadddr l )))  (f $tmp$$393 $tmp$$394 $tmp$$395 $tmp$$396 ))))) (void)))))))))))))) (void)) (begin  (set! assv (lambda (x f )  (let (($tmp$$377 (pair? f )))  (if $tmp$$377 (let (($tmp$$378 (car f )))  (let (($tmp$$379 (car $tmp$$378 )))  (let (($tmp$$380 (eqv? $tmp$$379 x )))  (if $tmp$$380 (car f ) (let (($tmp$$381 (cdr f )))  (assv x $tmp$$381 )))))) #f)))) (void)) (begin  (set! assq (lambda (x f )  (let (($tmp$$372 (pair? f )))  (if $tmp$$372 (let (($tmp$$373 (car f )))  (let (($tmp$$374 (car $tmp$$373 )))  (let (($tmp$$375 (eq? $tmp$$374 x )))  (if $tmp$$375 (car f ) (let (($tmp$$376 (cdr f )))  (assv x $tmp$$376 )))))) #f)))) (void)) (begin  (set! gensym-count 0) (void)) (begin  (set! gensym (lambda (name )  (begin  (let (($tmp$$367 (+ gensym-count 1 )))  (begin  (set! gensym-count $tmp$$367) (void))) (let (($tmp$$368 (symbol? name )))  (let (($tmp$$369 (if $tmp$$368 (symbol->string name ) name)))  (let (($tmp$$370 (number->string gensym-count )))  (let (($tmp$$371 (string-append $tmp$$369 "$" $tmp$$370 )))  (string->symbol $tmp$$371 )))))))) (void)) (begin  (set! three-d-tagged-list? (lambda (tag lst )  (let (($tmp$$359 (pair? lst )))  (if $tmp$$359 (let (($tmp$$361 (car lst )))  (let (($tmp$$360 (eq? $tmp$$361 tag )))  (if $tmp$$360 $tmp$$360 (let (($tmp$$362 (car lst )))  (let (($tmp$$363 (procedure? $tmp$$362 )))  (if $tmp$$363 (let (($tmp$$364 (car lst )))  (let (($tmp$$365 ($tmp$$364  )))  (let (($tmp$$366 (initial tag )))  (equal? $tmp$$365 $tmp$$366 )))) #f)))))) #f)))) (void)) (begin  (set! tagged-list? (lambda (tag lst )  (let (($tmp$$357 (pair? lst )))  (if $tmp$$357 (let (($tmp$$358 (car lst )))  (eq? $tmp$$358 tag )) #f)))) (void)) (begin  (set! singlet? (lambda (list )  (let (($tmp$$355 (pair? list )))  (if $tmp$$355 (let (($tmp$$356 (cdr list )))  (null? $tmp$$356 )) #f)))) (void)) (begin  (set! partition-k (lambda (pred list k )  (let (($tmp$$346 (pair? list )))  (let (($tmp$$347 (not $tmp$$346 )))  (if $tmp$$347 (k (quote ()) (quote ()) ) (let (($tmp$$348 (cdr list )))  (partition-k pred $tmp$$348 (lambda (trues falses )  (let (($tmp$$349 (car list )))  (let (($tmp$$350 (pred $tmp$$349 )))  (if $tmp$$350 (let (($tmp$$351 (car list )))  (let (($tmp$$352 (cons $tmp$$351 trues )))  (k $tmp$$352 falses ))) (let (($tmp$$353 (car list )))  (let (($tmp$$354 (cons $tmp$$353 falses )))  (k trues $tmp$$354 ))))))) ))))))) (void)) (begin  (set! unzip-amap-k (lambda (amap k )  (let (($tmp$$337 (pair? amap )))  (let (($tmp$$338 (not $tmp$$337 )))  (if $tmp$$338 (k (quote ()) (quote ()) ) (let (($tmp$$339 (cdr amap )))  (unzip-amap-k $tmp$$339 (lambda (xs ys )  (let (($tmp$$340 (car amap )))  (let (($tmp$$341 (car $tmp$$340 )))  (let (($tmp$$342 (cons $tmp$$341 xs )))  (let (($tmp$$343 (car amap )))  (let (($tmp$$344 (cadr $tmp$$343 )))  (let (($tmp$$345 (cons $tmp$$344 ys )))  (k $tmp$$342 $tmp$$345 )))))))) ))))))) (void)) (begin  (set! void (lambda ( )  (if #f #t (void)))) (void)) (begin  (set! define? (lambda (s-exp )  (tagged-list? (quote define) s-exp ))) (void)) (begin  (set! define-var? (lambda (s-exp )  (let (($tmp$$335 (define? s-exp )))  (if $tmp$$335 (let (($tmp$$336 (cadr s-exp )))  (symbol? $tmp$$336 )) #f)))) (void)) (begin  (set! define-fun? (lambda (s-exp )  (let (($tmp$$333 (define? s-exp )))  (if $tmp$$333 (let (($tmp$$334 (cadr s-exp )))  (pair? $tmp$$334 )) #f)))) (void)) (begin  (set! define->var (lambda (s-exp )  (let (($tmp$$331 (define-var? s-exp )))  (if $tmp$$331 (cadr s-exp ) (let (($tmp$$332 (define-fun? s-exp )))  (if $tmp$$332 (caadr s-exp ) (error "unknown define!" ))))))) (void)) (begin  (set! define->exp (lambda (s-exp )  (let (($tmp$$326 (define-var? s-exp )))  (if $tmp$$326 (caddr s-exp ) (let (($tmp$$327 (define-fun? s-exp )))  (if $tmp$$327 (let (($tmp$$328 (cdadr s-exp )))  (let (($tmp$$329 (cddr s-exp )))  (let (($tmp$$330 (cons $tmp$$328 $tmp$$329 )))  (cons three-d-lambda $tmp$$330 )))) (void))))))) (void)) (begin  (set! if? (lambda (s-exp )  (three-d-tagged-list? (quote if) s-exp ))) (void)) (begin  (set! if-single? (lambda (s-exp )  (let (($tmp$$324 (if? s-exp )))  (if $tmp$$324 (let (($tmp$$325 (cdddr s-exp )))  (null? $tmp$$325 )) #f)))) (void)) (begin  (set! if->cond (lambda (s-exp )  (cadr s-exp ))) (void)) (begin  (set! if->true (lambda (s-exp )  (caddr s-exp ))) (void)) (begin  (set! if->false (lambda (s-exp )  (cadddr s-exp ))) (void)) (begin  (set! quote? (lambda (s-exp )  (three-d-tagged-list? (quote quote) s-exp ))) (void)) (begin  (set! quote->text (lambda (s-exp )  (cadr s-exp ))) (void)) (begin  (set! lambda? (lambda (s-exp )  (three-d-tagged-list? (quote lambda) s-exp ))) (void)) (begin  (set! lambda-multi? (lambda (s-exp )  (let (($tmp$$322 (lambda? s-exp )))  (if $tmp$$322 (let (($tmp$$323 (cadr s-exp )))  (symbol? $tmp$$323 )) #f)))) (void)) (begin  (set! lambda->formals (lambda (s-exp )  (cadr s-exp ))) (void)) (begin  (set! lambda->body (lambda (s-exp )  (cddr s-exp ))) (void)) (begin  (set! lambda->body-as-exp (lambda (s-exp )  (let (($tmp$$321 (cddr s-exp )))  (make-begin $tmp$$321 )))) (void)) (begin  (set! begin? (lambda (s-exp )  (three-d-tagged-list? (quote begin) s-exp ))) (void)) (begin  (set! begin->body (lambda (s-exp )  (cdr s-exp ))) (void)) (begin  (set! make-begin (lambda (exps )  (let (($tmp$$320 (singlet? exps )))  (if $tmp$$320 (car exps ) (cons three-d-begin exps ))))) (void)) (begin  (set! app? (lambda (s-exp )  (pair? s-exp ))) (void)) (begin  (set! app->fun (lambda (s-exp )  (car s-exp ))) (void)) (begin  (set! app->args (lambda (s-exp )  (cdr s-exp ))) (void)) (begin  (set! binding->var (lambda (binding )  (car binding ))) (void)) (begin  (set! binding->exp (lambda (binding )  (cadr binding ))) (void)) (begin  (set! letrec? (lambda (s-exp )  (three-d-tagged-list? (quote letrec) s-exp ))) (void)) (begin  (set! letrec->bindings (lambda (s-exp )  (cadr s-exp ))) (void)) (begin  (set! letrec->body (lambda (s-exp )  (cddr s-exp ))) (void)) (begin  (set! letrec->body-as-exp (lambda (s-exp )  (let (($tmp$$319 (letrec->body s-exp )))  (make-begin $tmp$$319 )))) (void)) (begin  (set! let? (lambda (s-exp )  (three-d-tagged-list? (quote let) s-exp ))) (void)) (begin  (set! let->bindings (lambda (s-exp )  (cadr s-exp ))) (void)) (begin  (set! let->body (lambda (s-exp )  (cddr s-exp ))) (void)) (begin  (set! let->body-as-exp (lambda (s-exp )  (let (($tmp$$318 (let->body s-exp )))  (make-begin $tmp$$318 )))) (void)) (begin  (set! let*? (lambda (s-exp )  (three-d-tagged-list? (quote let*) s-exp ))) (void)) (begin  (set! let*->bindings (lambda (s-exp )  (cadr s-exp ))) (void)) (begin  (set! let*->body (lambda (s-exp )  (cddr s-exp ))) (void)) (begin  (set! let*->body-as-exp (lambda (s-exp )  (let (($tmp$$317 (let*->body s-exp )))  (make-begin $tmp$$317 )))) (void)) (begin  (set! or? (lambda (s-exp )  (three-d-tagged-list? (quote or) s-exp ))) (void)) (begin  (set! or->exps (lambda (s-exp )  (cdr s-exp ))) (void)) (begin  (set! make-or (lambda (exps )  (let (($tmp$$315 (null? exps )))  (if $tmp$$315 #f (let (($tmp$$316 (singlet? exps )))  (if $tmp$$316 (car exps ) (cons (quote or) exps ))))))) (void)) (begin  (set! and? (lambda (s-exp )  (three-d-tagged-list? (quote and) s-exp ))) (void)) (begin  (set! and->exps (lambda (s-exp )  (cdr s-exp ))) (void)) (begin  (set! make-and (lambda (exps )  (let (($tmp$$313 (null? exps )))  (if $tmp$$313 #t (let (($tmp$$314 (singlet? exps )))  (if $tmp$$314 (car exps ) (cons (quote and) exps ))))))) (void)) (begin  (set! cond? (lambda (s-exp )  (three-d-tagged-list? (quote cond) s-exp ))) (void)) (begin  (set! cond->clauses (lambda (s-exp )  (cdr s-exp ))) (void)) (begin  (set! arrow-clause? (lambda (clause )  (let (($tmp$$309 (pair? clause )))  (if $tmp$$309 (let (($tmp$$310 (cdr clause )))  (let (($tmp$$311 (pair? $tmp$$310 )))  (if $tmp$$311 (let (($tmp$$312 (cadr clause )))  (eq? $tmp$$312 (quote =>) )) #f))) #f)))) (void)) (begin  (set! else-clause? (lambda (clause )  (three-d-tagged-list? (quote else) clause ))) (void)) (begin  (set! cond-clause->exp (lambda (clause )  (let (($tmp$$305 (singlet? clause )))  (if $tmp$$305 (car clause ) (let (($tmp$$306 (else-clause? clause )))  (if $tmp$$306 (cadr clause ) (let (($tmp$$307 (arrow-clause? clause )))  (if $tmp$$307 (caddr clause ) (let (($tmp$$308 (cdr clause )))  (make-begin $tmp$$308 )))))))))) (void)) (begin  (set! cond-clause->test (lambda (clause )  (let (($tmp$$302 (singlet? clause )))  (if $tmp$$302 (car clause ) (let (($tmp$$303 (else-clause? clause )))  (if $tmp$$303 #t (let (($tmp$$304 (arrow-clause? clause )))  (if $tmp$$304 (car clause ) (car clause ))))))))) (void)) (begin  (set! set!? (lambda (s-exp )  (three-d-tagged-list? (quote set!) s-exp ))) (void)) (begin  (set! set!->var (lambda (s-exp )  (cadr s-exp ))) (void)) (begin  (set! set!->exp (lambda (s-exp )  (caddr s-exp ))) (void)) (begin  (set! macro? (lambda (s-exp )  (three-d-tagged-list? (quote macro) s-exp ))) (void)) (begin  (set! macro->proc (lambda (s-exp )  (cadr s-exp ))) (void)) (begin  (set! syntax-primitive? (lambda (value )  (three-d-tagged-list? (quote syntax-primitive) value ))) (void)) (begin  (set! syntax-primitive->eval (lambda (value )  (cadr value ))) (void)) (begin  (set! def->binding (lambda (def )  (let (($tmp$$299 (define->var def )))  (let (($tmp$$300 (define->exp def )))  (let (($tmp$$301 (cons $tmp$$300 (quote ()) )))  (cons $tmp$$299 $tmp$$301 )))))) (void)) (begin  (set! body->letrec (lambda (decs )  (partition-k define? decs (lambda (defs exps )  (let (($tmp$$295 (null? defs )))  (if $tmp$$295 (make-begin exps ) (let ((bindings (map def->binding defs )))  (let (($tmp$$296 (make-begin exps )))  (let (($tmp$$297 (cons $tmp$$296 (quote ()) )))  (let (($tmp$$298 (cons bindings $tmp$$297 )))  (cons three-d-letrec $tmp$$298 )))))))) ))) (void)) (begin  (set! letrec->lets+sets (lambda (exp )  (let (($tmp$$280 (letrec? exp )))  (let (($tmp$$281 (not $tmp$$280 )))  (if $tmp$$281 exp (let (($tmp$$284 (letrec->bindings exp )))  (let ((bindings (map (lambda (binding )  (let (($tmp$$282 (binding->var binding )))  (let (($tmp$$283 (cons #f (quote ()) )))  (cons $tmp$$282 $tmp$$283 )))) $tmp$$284 )))  (let (($tmp$$289 (letrec->bindings exp )))  (let ((sets (map (lambda (binding )  (let (($tmp$$285 (binding->var binding )))  (let (($tmp$$286 (binding->exp binding )))  (let (($tmp$$287 (cons $tmp$$286 (quote ()) )))  (let (($tmp$$288 (cons $tmp$$285 $tmp$$287 )))  (cons three-d-set! $tmp$$288 )))))) $tmp$$289 )))  (let (($tmp$$290 (letrec->body exp )))  (let (($tmp$$291 (append sets $tmp$$290 )))  (let (($tmp$$292 (make-begin $tmp$$291 )))  (let (($tmp$$293 (cons $tmp$$292 (quote ()) )))  (let (($tmp$$294 (cons bindings $tmp$$293 )))  (cons three-d-let $tmp$$294 ))))))))))))))) (void)) (begin  (set! cond->if (lambda (cond-exp )  (let (($tmp$$277 (cond? cond-exp )))  (let (($tmp$$278 (not $tmp$$277 )))  (if $tmp$$278 cond-exp (let (($tmp$$279 (cond->clauses cond-exp )))  (cond-clauses->if $tmp$$279 ))))))) (void)) (begin  (set! cond-clauses->if (lambda (clauses )  (let (($tmp$$264 (null? clauses )))  (if $tmp$$264 (cons (quote void) (quote ()) ) (let ((clause (car clauses )))  (let (($tmp$$265 (singlet? clause )))  (if $tmp$$265 (let (($tmp$$266 (cdr clauses )))  (let (($tmp$$267 (cond-clauses->if $tmp$$266 )))  (let (($tmp$$268 (cons clause $tmp$$267 )))  (make-or $tmp$$268 )))) (let (($tmp$$269 (else-clause? clause )))  (if $tmp$$269 (cond-clause->exp clause ) (let (($tmp$$270 (cond-clause->test clause )))  (let (($tmp$$271 (cond-clause->exp clause )))  (let (($tmp$$272 (cdr clauses )))  (let (($tmp$$273 (cond-clauses->if $tmp$$272 )))  (let (($tmp$$274 (cons $tmp$$273 (quote ()) )))  (let (($tmp$$275 (cons $tmp$$271 $tmp$$274 )))  (let (($tmp$$276 (cons $tmp$$270 $tmp$$275 )))  (cons three-d-if $tmp$$276 ))))))))))))))))) (void)) (begin  (set! and->if (lambda (exp )  (let (($tmp$$253 (and? exp )))  (let (($tmp$$254 (not $tmp$$253 )))  (if $tmp$$254 exp (let ((exps (and->exps exp )))  (let (($tmp$$255 (null? exps )))  (if $tmp$$255 #t (let (($tmp$$256 (singlet? exps )))  (if $tmp$$256 (car exps ) (let (($tmp$$257 (car exps )))  (let (($tmp$$258 (cdr exps )))  (let (($tmp$$259 (cons (quote and) $tmp$$258 )))  (let (($tmp$$260 (and->if $tmp$$259 )))  (let (($tmp$$261 (cons #f (quote ()) )))  (let (($tmp$$262 (cons $tmp$$260 $tmp$$261 )))  (let (($tmp$$263 (cons $tmp$$257 $tmp$$262 )))  (cons three-d-if $tmp$$263 )))))))))))))))))) (void)) (begin  (set! or->if (lambda (exp )  (let (($tmp$$236 (or? exp )))  (let (($tmp$$237 (not $tmp$$236 )))  (if $tmp$$237 exp (let ((exps (or->exps exp )))  (let (($tmp$$238 (null? exps )))  (if $tmp$$238 #f (let (($tmp$$239 (singlet? exps )))  (if $tmp$$239 (car exps ) (let (($tmp (gensym "or-tmp" )))  (let (($tmp$$240 (car exps )))  (let (($tmp$$241 (cons $tmp$$240 (quote ()) )))  (let (($tmp$$242 (cons $tmp $tmp$$241 )))  (let (($tmp$$243 (cons $tmp$$242 (quote ()) )))  (let (($tmp$$244 (cdr exps )))  (let (($tmp$$245 (cons three-d-or $tmp$$244 )))  (let (($tmp$$246 (or->if $tmp$$245 )))  (let (($tmp$$247 (cons $tmp$$246 (quote ()) )))  (let (($tmp$$248 (cons $tmp $tmp$$247 )))  (let (($tmp$$249 (cons $tmp $tmp$$248 )))  (let (($tmp$$250 (cons three-d-if $tmp$$249 )))  (let (($tmp$$251 (cons $tmp$$250 (quote ()) )))  (let (($tmp$$252 (cons $tmp$$243 $tmp$$251 )))  (cons three-d-let $tmp$$252 ))))))))))))))))))))))))) (void)) (begin  (set! let*->let (lambda (exp )  (let (($tmp$$232 (let*? exp )))  (let (($tmp$$233 (not $tmp$$232 )))  (if $tmp$$233 exp (let (($tmp$$234 (let*->bindings exp )))  (let (($tmp$$235 (let*->body exp )))  (let*-bindings->let $tmp$$234 $tmp$$235 )))))))) (void)) (begin  (set! let*-bindings->let (lambda (bindings body )  (let (($tmp$$221 (singlet? bindings )))  (if $tmp$$221 (let (($tmp$$222 (car bindings )))  (let (($tmp$$223 (cons $tmp$$222 (quote ()) )))  (let (($tmp$$224 (cons $tmp$$223 body )))  (cons three-d-let $tmp$$224 )))) (let (($tmp$$225 (null? bindings )))  (if $tmp$$225 (make-begin body ) (let (($tmp$$226 (car bindings )))  (let (($tmp$$227 (cons $tmp$$226 (quote ()) )))  (let (($tmp$$228 (cdr bindings )))  (let (($tmp$$229 (let*-bindings->let $tmp$$228 body )))  (let (($tmp$$230 (cons $tmp$$229 (quote ()) )))  (let (($tmp$$231 (cons $tmp$$227 $tmp$$230 )))  (cons three-d-let $tmp$$231 ))))))))))))) (void)) (begin  (set! let->app (lambda (exp )  (let (($tmp$$215 (let? exp )))  (let (($tmp$$216 (not $tmp$$215 )))  (if $tmp$$216 exp (let (($tmp$$217 (let->bindings exp )))  (unzip-amap-k $tmp$$217 (lambda (vars exps )  (let (($tmp$$218 (let->body exp )))  (let (($tmp$$219 (cons vars $tmp$$218 )))  (let (($tmp$$220 (cons three-d-lambda $tmp$$219 )))  (cons $tmp$$220 exps ))))) ))))))) (void)) (begin  (set! eval (lambda (exp env )  (let (($tmp$$207 (symbol? exp )))  (if $tmp$$207 (env-lookup env exp ) (let (($tmp$$208 (number? exp )))  (if $tmp$$208 exp (let (($tmp$$209 (boolean? exp )))  (if $tmp$$209 exp (let (($tmp$$210 (string? exp )))  (if $tmp$$210 exp (let (($tmp$$211 (procedure? exp )))  (if $tmp$$211 (exp  ) (let (($tmp$$212 (app? exp )))  (if $tmp$$212 (let (($tmp$$213 (app->fun exp )))  (let (($tmp$$214 (eval $tmp$$213 env )))  (perform-apply $tmp$$214 exp env ))) (void))))))))))))))) (void)) (begin  (set! eval-with (lambda (env )  (lambda (exp )  (eval exp env )))) (void)) (begin  (set! eval* (lambda (exps env )  (let (($tmp$$206 (eval-with env )))  (map $tmp$$206 exps )))) (void)) (begin  (set! eval-quote (lambda (exp env )  (quote->text exp ))) (void)) (begin  (set! eval-if (lambda (exp env )  (let (($tmp$$198 (if-single? exp )))  (if $tmp$$198 (let (($tmp$$199 (if->cond exp )))  (let (($tmp$$200 (eval $tmp$$199 env )))  (if $tmp$$200 (let (($tmp$$201 (if->true exp )))  (eval $tmp$$201 env )) (void)))) (let (($tmp$$202 (if->cond exp )))  (let (($tmp$$203 (eval $tmp$$202 env )))  (if $tmp$$203 (let (($tmp$$204 (if->true exp )))  (eval $tmp$$204 env )) (let (($tmp$$205 (if->false exp )))  (eval $tmp$$205 env ))))))))) (void)) (begin  (set! eval-cond (lambda (exp env )  (let (($tmp$$197 (cond->if exp )))  (eval $tmp$$197 env )))) (void)) (begin  (set! eval-and (lambda (exp env )  (let (($tmp$$196 (and->if exp )))  (eval $tmp$$196 env )))) (void)) (begin  (set! eval-or (lambda (exp env )  (let (($tmp$$195 (or->if exp )))  (eval $tmp$$195 env )))) (void)) (begin  (set! eval-let (lambda (exp env )  (let (($tmp$$194 (let->app exp )))  (eval $tmp$$194 env )))) (void)) (begin  (set! eval-let* (lambda (exp env )  (let (($tmp$$193 (let*->let exp )))  (eval $tmp$$193 env )))) (void)) (begin  (set! eval-letrec (lambda (exp env )  (let (($tmp$$192 (letrec->lets+sets exp )))  (eval $tmp$$192 env )))) (void)) (begin  (set! eval-begin (lambda (exp env )  (let (($tmp$$187 (begin->body exp )))  (let ((simplified (body->letrec $tmp$$187 )))  (let (($tmp$$188 (begin? simplified )))  (if $tmp$$188 (let (($tmp$$189 (begin->body exp )))  (let (($tmp$$190 (eval* $tmp$$189 env )))  (let (($tmp$$191 (reverse $tmp$$190 )))  (car $tmp$$191 )))) (eval simplified env ))))))) (void)) (begin  (set! eval-set! (lambda (exp env )  (let (($tmp$$184 (set!->var exp )))  (let (($tmp$$185 (set!->exp exp )))  (let (($tmp$$186 (eval $tmp$$185 env )))  (env-set! env $tmp$$184 $tmp$$186 )))))) (void)) (begin  (set! eval-lambda (lambda (exp env )  (let ((formals (lambda->formals exp )))  (lambda args  (let (($tmp$$179 (symbol? formals )))  (if $tmp$$179 (let (($tmp$$180 (lambda->body-as-exp exp )))  (let (($tmp$$181 (env-extend env formals args )))  (eval $tmp$$180 $tmp$$181 ))) (let (($tmp$$182 (lambda->body-as-exp exp )))  (let (($tmp$$183 (env-extend* env formals args )))  (eval $tmp$$182 $tmp$$183 ))))))))) (void)) (begin  (set! eval-macro (lambda (exp env )  (let (($tmp$$176 (macro->proc exp )))  (let (($tmp$$177 (eval $tmp$$176 env )))  (let (($tmp$$178 (cons $tmp$$177 (quote ()) )))  (cons (quote macro) $tmp$$178 )))))) (void)) (begin  (set! env-lookup (lambda (env var )  (let ((value (env var #f (quote unused) )))  value))) (void)) (begin  (set! env-set! (lambda (env var value )  (env var #t value ))) (void)) (begin  (set! env-extend (lambda (env var value )  (lambda (seek-var modify? value! )  (let (($tmp$$175 (eq? var seek-var )))  (if $tmp$$175 (if modify? (begin  (set! value value!) (void)) value) (env seek-var modify? value! )))))) (void)) (begin  (set! env-extend* (lambda (env vars values )  (let (($tmp$$169 (pair? vars )))  (if $tmp$$169 (let (($tmp$$170 (car vars )))  (let (($tmp$$171 (car values )))  (let (($tmp$$172 (env-extend env $tmp$$170 $tmp$$171 )))  (let (($tmp$$173 (cdr vars )))  (let (($tmp$$174 (cdr values )))  (env-extend* $tmp$$172 $tmp$$173 $tmp$$174 )))))) env)))) (void)) (begin  (set! empty-env (lambda (var modify? value! )  (begin  (if modify? (begin  (display "error: cannot modify undefined variable: " ) (begin  (display var ) (begin  (display " with " ) (display value! )))) (begin  (display "error: cannot look up undefined variable: " ) (display var ))) (begin  (newline  ) (error  ))))) (void)) (let (($tmp$$37 (cons apply (quote ()) )))  (let (($tmp$$38 (cons (quote apply) $tmp$$37 )))  (let (($tmp$$39 (cons + (quote ()) )))  (let (($tmp$$40 (cons (quote +) $tmp$$39 )))  (let (($tmp$$41 (cons not (quote ()) )))  (let (($tmp$$42 (cons (quote not) $tmp$$41 )))  (let (($tmp$$43 (cons display (quote ()) )))  (let (($tmp$$44 (cons (quote display) $tmp$$43 )))  (let (($tmp$$45 (cons newline (quote ()) )))  (let (($tmp$$46 (cons (quote newline) $tmp$$45 )))  (let (($tmp$$47 (cons cons (quote ()) )))  (let (($tmp$$48 (cons (quote cons) $tmp$$47 )))  (let (($tmp$$49 (cons car (quote ()) )))  (let (($tmp$$50 (cons (quote car) $tmp$$49 )))  (let (($tmp$$51 (cons cdr (quote ()) )))  (let (($tmp$$52 (cons (quote cdr) $tmp$$51 )))  (let (($tmp$$53 (cons cadr (quote ()) )))  (let (($tmp$$54 (cons (quote cadr) $tmp$$53 )))  (let (($tmp$$55 (cons caadr (quote ()) )))  (let (($tmp$$56 (cons (quote caadr) $tmp$$55 )))  (let (($tmp$$57 (cons cadar (quote ()) )))  (let (($tmp$$58 (cons (quote cadar) $tmp$$57 )))  (let (($tmp$$59 (cons cddr (quote ()) )))  (let (($tmp$$60 (cons (quote cddr) $tmp$$59 )))  (let (($tmp$$61 (cons cdddr (quote ()) )))  (let (($tmp$$62 (cons (quote cdddr) $tmp$$61 )))  (let (($tmp$$63 (cons null? (quote ()) )))  (let (($tmp$$64 (cons (quote null?) $tmp$$63 )))  (let (($tmp$$65 (cons pair? (quote ()) )))  (let (($tmp$$66 (cons (quote pair?) $tmp$$65 )))  (let (($tmp$$67 (cons list? (quote ()) )))  (let (($tmp$$68 (cons (quote list?) $tmp$$67 )))  (let (($tmp$$69 (cons number? (quote ()) )))  (let (($tmp$$70 (cons (quote number?) $tmp$$69 )))  (let (($tmp$$71 (cons string? (quote ()) )))  (let (($tmp$$72 (cons (quote string?) $tmp$$71 )))  (let (($tmp$$73 (cons symbol? (quote ()) )))  (let (($tmp$$74 (cons (quote symbol?) $tmp$$73 )))  (let (($tmp$$75 (cons procedure? (quote ()) )))  (let (($tmp$$76 (cons (quote procedure?) $tmp$$75 )))  (let (($tmp$$77 (cons eq? (quote ()) )))  (let (($tmp$$78 (cons (quote eq?) $tmp$$77 )))  (let (($tmp$$79 (cons = (quote ()) )))  (let (($tmp$$80 (cons (quote =) $tmp$$79 )))  (let (($tmp$$81 (cons gensym (quote ()) )))  (let (($tmp$$82 (cons (quote gensym) $tmp$$81 )))  (let (($tmp$$83 (cons void (quote ()) )))  (let (($tmp$$84 (cons (quote void) $tmp$$83 )))  (let (($tmp$$85 (cons eval-quote (quote ()) )))  (let (($tmp$$86 (cons (quote syntax-primitive) $tmp$$85 )))  (let (($tmp$$87 (cons $tmp$$86 (quote ()) )))  (let (($tmp$$88 (cons (quote quote) $tmp$$87 )))  (let (($tmp$$89 (cons eval-if (quote ()) )))  (let (($tmp$$90 (cons (quote syntax-primitive) $tmp$$89 )))  (let (($tmp$$91 (cons $tmp$$90 (quote ()) )))  (let (($tmp$$92 (cons (quote if) $tmp$$91 )))  (let (($tmp$$93 (cons eval-cond (quote ()) )))  (let (($tmp$$94 (cons (quote syntax-primitive) $tmp$$93 )))  (let (($tmp$$95 (cons $tmp$$94 (quote ()) )))  (let (($tmp$$96 (cons (quote cond) $tmp$$95 )))  (let (($tmp$$97 (cons eval-and (quote ()) )))  (let (($tmp$$98 (cons (quote syntax-primitive) $tmp$$97 )))  (let (($tmp$$99 (cons $tmp$$98 (quote ()) )))  (let (($tmp$$100 (cons (quote and) $tmp$$99 )))  (let (($tmp$$101 (cons eval-or (quote ()) )))  (let (($tmp$$102 (cons (quote syntax-primitive) $tmp$$101 )))  (let (($tmp$$103 (cons $tmp$$102 (quote ()) )))  (let (($tmp$$104 (cons (quote or) $tmp$$103 )))  (let (($tmp$$105 (cons eval-let (quote ()) )))  (let (($tmp$$106 (cons (quote syntax-primitive) $tmp$$105 )))  (let (($tmp$$107 (cons $tmp$$106 (quote ()) )))  (let (($tmp$$108 (cons (quote let) $tmp$$107 )))  (let (($tmp$$109 (cons eval-let* (quote ()) )))  (let (($tmp$$110 (cons (quote syntax-primitive) $tmp$$109 )))  (let (($tmp$$111 (cons $tmp$$110 (quote ()) )))  (let (($tmp$$112 (cons (quote let*) $tmp$$111 )))  (let (($tmp$$113 (cons eval-letrec (quote ()) )))  (let (($tmp$$114 (cons (quote syntax-primitive) $tmp$$113 )))  (let (($tmp$$115 (cons $tmp$$114 (quote ()) )))  (let (($tmp$$116 (cons (quote letrec) $tmp$$115 )))  (let (($tmp$$117 (cons eval-begin (quote ()) )))  (let (($tmp$$118 (cons (quote syntax-primitive) $tmp$$117 )))  (let (($tmp$$119 (cons $tmp$$118 (quote ()) )))  (let (($tmp$$120 (cons (quote begin) $tmp$$119 )))  (let (($tmp$$121 (cons eval-set! (quote ()) )))  (let (($tmp$$122 (cons (quote syntax-primitive) $tmp$$121 )))  (let (($tmp$$123 (cons $tmp$$122 (quote ()) )))  (let (($tmp$$124 (cons (quote set!) $tmp$$123 )))  (let (($tmp$$125 (cons eval-lambda (quote ()) )))  (let (($tmp$$126 (cons (quote syntax-primitive) $tmp$$125 )))  (let (($tmp$$127 (cons $tmp$$126 (quote ()) )))  (let (($tmp$$128 (cons (quote lambda) $tmp$$127 )))  (let (($tmp$$129 (cons eval-macro (quote ()) )))  (let (($tmp$$130 (cons (quote syntax-primitive) $tmp$$129 )))  (let (($tmp$$131 (cons $tmp$$130 (quote ()) )))  (let (($tmp$$132 (cons (quote macro) $tmp$$131 )))  (let (($tmp$$133 (cons $tmp$$132 (quote ()) )))  (let (($tmp$$134 (cons $tmp$$128 $tmp$$133 )))  (let (($tmp$$135 (cons $tmp$$124 $tmp$$134 )))  (let (($tmp$$136 (cons $tmp$$120 $tmp$$135 )))  (let (($tmp$$137 (cons $tmp$$116 $tmp$$136 )))  (let (($tmp$$138 (cons $tmp$$112 $tmp$$137 )))  (let (($tmp$$139 (cons $tmp$$108 $tmp$$138 )))  (let (($tmp$$140 (cons $tmp$$104 $tmp$$139 )))  (let (($tmp$$141 (cons $tmp$$100 $tmp$$140 )))  (let (($tmp$$142 (cons $tmp$$96 $tmp$$141 )))  (let (($tmp$$143 (cons $tmp$$92 $tmp$$142 )))  (let (($tmp$$144 (cons $tmp$$88 $tmp$$143 )))  (let (($tmp$$145 (cons $tmp$$84 $tmp$$144 )))  (let (($tmp$$146 (cons $tmp$$82 $tmp$$145 )))  (let (($tmp$$147 (cons $tmp$$80 $tmp$$146 )))  (let (($tmp$$148 (cons $tmp$$78 $tmp$$147 )))  (let (($tmp$$149 (cons $tmp$$76 $tmp$$148 )))  (let (($tmp$$150 (cons $tmp$$74 $tmp$$149 )))  (let (($tmp$$151 (cons $tmp$$72 $tmp$$150 )))  (let (($tmp$$152 (cons $tmp$$70 $tmp$$151 )))  (let (($tmp$$153 (cons $tmp$$68 $tmp$$152 )))  (let (($tmp$$154 (cons $tmp$$66 $tmp$$153 )))  (let (($tmp$$155 (cons $tmp$$64 $tmp$$154 )))  (let (($tmp$$156 (cons $tmp$$62 $tmp$$155 )))  (let (($tmp$$157 (cons $tmp$$60 $tmp$$156 )))  (let (($tmp$$158 (cons $tmp$$58 $tmp$$157 )))  (let (($tmp$$159 (cons $tmp$$56 $tmp$$158 )))  (let (($tmp$$160 (cons $tmp$$54 $tmp$$159 )))  (let (($tmp$$161 (cons $tmp$$52 $tmp$$160 )))  (let (($tmp$$162 (cons $tmp$$50 $tmp$$161 )))  (let (($tmp$$163 (cons $tmp$$48 $tmp$$162 )))  (let (($tmp$$164 (cons $tmp$$46 $tmp$$163 )))  (let (($tmp$$165 (cons $tmp$$44 $tmp$$164 )))  (let (($tmp$$166 (cons $tmp$$42 $tmp$$165 )))  (let (($tmp$$167 (cons $tmp$$40 $tmp$$166 )))  (let (($tmp$$168 (cons $tmp$$38 $tmp$$167 )))  (begin  (set! initial-environment-amap $tmp$$168) (void)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) (begin  (set! initial-environment (lambda ( )  (unzip-amap-k initial-environment-amap (lambda (symbols values )  (env-extend* empty-env symbols values )) ))) (void)) (begin  (set! initial (lambda (sym )  (let (($tmp$$36 (initial-environment  )))  (env-lookup $tmp$$36 sym )))) (void)) (begin  (set! three-d (lambda (value )  (lambda ( )  value))) (void)) (let (($tmp$$34 (initial (quote quote) )))  (let (($tmp$$35 (three-d $tmp$$34 )))  (begin  (set! three-d-quote $tmp$$35) (void)))) (let (($tmp$$32 (initial (quote if) )))  (let (($tmp$$33 (three-d $tmp$$32 )))  (begin  (set! three-d-if $tmp$$33) (void)))) (let (($tmp$$30 (initial (quote cond) )))  (let (($tmp$$31 (three-d $tmp$$30 )))  (begin  (set! three-d-cond $tmp$$31) (void)))) (let (($tmp$$28 (initial (quote and) )))  (let (($tmp$$29 (three-d $tmp$$28 )))  (begin  (set! three-d-and $tmp$$29) (void)))) (let (($tmp$$26 (initial (quote or) )))  (let (($tmp$$27 (three-d $tmp$$26 )))  (begin  (set! three-d-or $tmp$$27) (void)))) (let (($tmp$$24 (initial (quote let) )))  (let (($tmp$$25 (three-d $tmp$$24 )))  (begin  (set! three-d-let $tmp$$25) (void)))) (let (($tmp$$22 (initial (quote let*) )))  (let (($tmp$$23 (three-d $tmp$$22 )))  (begin  (set! three-d-let* $tmp$$23) (void)))) (let (($tmp$$20 (initial (quote letrec) )))  (let (($tmp$$21 (three-d $tmp$$20 )))  (begin  (set! three-d-letrec $tmp$$21) (void)))) (let (($tmp$$18 (initial (quote set!) )))  (let (($tmp$$19 (three-d $tmp$$18 )))  (begin  (set! three-d-set! $tmp$$19) (void)))) (let (($tmp$$16 (initial (quote lambda) )))  (let (($tmp$$17 (three-d $tmp$$16 )))  (begin  (set! three-d-lambda $tmp$$17) (void)))) (let (($tmp$$14 (initial (quote begin) )))  (let (($tmp$$15 (three-d $tmp$$14 )))  (begin  (set! three-d-begin $tmp$$15) (void)))) (begin  (set! perform-apply (lambda (fun app-exp env )  (let ((args (app->args app-exp )))  (let (($tmp$$9 (macro? fun )))  (if $tmp$$9 (let (($tmp$$10 (macro->proc fun )))  (let (($tmp$$11 (apply $tmp$$10 args )))  (eval $tmp$$11 env ))) (let (($tmp$$12 (syntax-primitive? fun )))  (if $tmp$$12 (let (($tmp$$13 (syntax-primitive->eval fun )))  ($tmp$$13 app-exp env )) (let ((arg-values (eval* args env )))  (apply fun arg-values ))))))))) (void)) (let (($tmp$$1 (cons (quote x) (quote ()) )))  (let (($tmp$$2 (cons (quote x) (quote ()) )))  (let (($tmp$$3 (cons $tmp$$1 $tmp$$2 )))  (let (($tmp$$4 (cons (quote lambda) $tmp$$3 )))  (let (($tmp$$5 (cons (quote 10) (quote ()) )))  (let (($tmp$$6 (cons $tmp$$4 $tmp$$5 )))  (let (($tmp$$7 (initial-environment  )))  (let (($tmp$$8 (eval $tmp$$6 $tmp$$7 )))  (begin  (set! _$$1 $tmp$$8) (void)))))))))) _$$1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))


CPS program:
((lambda (cadr )  ((lambda (cddr )  ((lambda (cdddr )  ((lambda (caadr )  ((lambda (caddr )  ((lambda (cadar )  ((lambda (cadddr )  ((lambda (map )  ((lambda (for-each )  ((lambda (append )  ((lambda (string->list )  ((lambda (apply )  ((lambda (assv )  ((lambda (assq )  ((lambda (gensym-count )  ((lambda (gensym )  ((lambda (three-d-tagged-list? )  ((lambda (tagged-list? )  ((lambda (singlet? )  ((lambda (partition-k )  ((lambda (unzip-amap-k )  ((lambda (void )  ((lambda (define? )  ((lambda (define-var? )  ((lambda (define-fun? )  ((lambda (define->var )  ((lambda (define->exp )  ((lambda (if? )  ((lambda (if-single? )  ((lambda (if->cond )  ((lambda (if->true )  ((lambda (if->false )  ((lambda (quote? )  ((lambda (quote->text )  ((lambda (lambda? )  ((lambda (lambda-multi? )  ((lambda (lambda->formals )  ((lambda (lambda->body )  ((lambda (lambda->body-as-exp )  ((lambda (begin? )  ((lambda (begin->body )  ((lambda (make-begin )  ((lambda (app? )  ((lambda (app->fun )  ((lambda (app->args )  ((lambda (binding->var )  ((lambda (binding->exp )  ((lambda (letrec? )  ((lambda (letrec->bindings )  ((lambda (letrec->body )  ((lambda (letrec->body-as-exp )  ((lambda (let? )  ((lambda (let->bindings )  ((lambda (let->body )  ((lambda (let->body-as-exp )  ((lambda (let*? )  ((lambda (let*->bindings )  ((lambda (let*->body )  ((lambda (let*->body-as-exp )  ((lambda (or? )  ((lambda (or->exps )  ((lambda (make-or )  ((lambda (and? )  ((lambda (and->exps )  ((lambda (make-and )  ((lambda (cond? )  ((lambda (cond->clauses )  ((lambda (arrow-clause? )  ((lambda (else-clause? )  ((lambda (cond-clause->exp )  ((lambda (cond-clause->test )  ((lambda (set!? )  ((lambda (set!->var )  ((lambda (set!->exp )  ((lambda (macro? )  ((lambda (macro->proc )  ((lambda (syntax-primitive? )  ((lambda (syntax-primitive->eval )  ((lambda (def->binding )  ((lambda (body->letrec )  ((lambda (letrec->lets+sets )  ((lambda (cond->if )  ((lambda (cond-clauses->if )  ((lambda (and->if )  ((lambda (or->if )  ((lambda (let*->let )  ((lambda (let*-bindings->let )  ((lambda (let->app )  ((lambda (eval )  ((lambda (eval-with )  ((lambda (eval* )  ((lambda (eval-quote )  ((lambda (eval-if )  ((lambda (eval-cond )  ((lambda (eval-and )  ((lambda (eval-or )  ((lambda (eval-let )  ((lambda (eval-let* )  ((lambda (eval-letrec )  ((lambda (eval-begin )  ((lambda (eval-set! )  ((lambda (eval-lambda )  ((lambda (eval-macro )  ((lambda (env-lookup )  ((lambda (env-set! )  ((lambda (env-extend )  ((lambda (env-extend* )  ((lambda (empty-env )  ((lambda (initial-environment-amap )  ((lambda (initial-environment )  ((lambda (initial )  ((lambda (three-d )  ((lambda (three-d-quote )  ((lambda (three-d-if )  ((lambda (three-d-cond )  ((lambda (three-d-and )  ((lambda (three-d-or )  ((lambda (three-d-let )  ((lambda (three-d-let* )  ((lambda (three-d-letrec )  ((lambda (three-d-set! )  ((lambda (three-d-lambda )  ((lambda (three-d-begin )  ((lambda (perform-apply )  ((lambda (_$$1 )  (begin  (set! cadr (lambda (p #:cc cc$$123)  (cdr p #:cc (lambda ($tmp$$429 )  (car $tmp$$429 #:cc cc$$123))))) ((lambda _$$263  ((lambda _$$262  (begin  (set! cddr (lambda (p #:cc cc$$122)  (cdr p #:cc (lambda ($tmp$$428 )  (cdr $tmp$$428 #:cc cc$$122))))) ((lambda _$$261  ((lambda _$$260  (begin  (set! cdddr (lambda (p #:cc cc$$121)  (cdr p #:cc (lambda ($tmp$$426 )  (cdr $tmp$$426 #:cc (lambda ($tmp$$427 )  (cdr $tmp$$427 #:cc cc$$121))))))) ((lambda _$$259  ((lambda _$$258  (begin  (set! caadr (lambda (p #:cc cc$$120)  (cdr p #:cc (lambda ($tmp$$424 )  (car $tmp$$424 #:cc (lambda ($tmp$$425 )  (car $tmp$$425 #:cc cc$$120))))))) ((lambda _$$257  ((lambda _$$256  (begin  (set! caddr (lambda (p #:cc cc$$119)  (cdr p #:cc (lambda ($tmp$$422 )  (cdr $tmp$$422 #:cc (lambda ($tmp$$423 )  (car $tmp$$423 #:cc cc$$119))))))) ((lambda _$$255  ((lambda _$$254  (begin  (set! cadar (lambda (p #:cc cc$$118)  (car p #:cc (lambda ($tmp$$420 )  (cdr $tmp$$420 #:cc (lambda ($tmp$$421 )  (car $tmp$$421 #:cc cc$$118))))))) ((lambda _$$253  ((lambda _$$252  (begin  (set! cadddr (lambda (p #:cc cc$$117)  (cdr p #:cc (lambda ($tmp$$417 )  (cdr $tmp$$417 #:cc (lambda ($tmp$$418 )  (cdr $tmp$$418 #:cc (lambda ($tmp$$419 )  (car $tmp$$419 #:cc cc$$117))))))))) ((lambda _$$251  ((lambda _$$250  (begin  (set! map (lambda (f lst #:cc cc$$116)  (pair? lst #:cc (lambda ($tmp$$412 )  (if $tmp$$412 (car lst #:cc (lambda ($tmp$$413 )  (f $tmp$$413 #:cc (lambda ($tmp$$414 )  (cdr lst #:cc (lambda ($tmp$$415 )  (map f $tmp$$415 #:cc (lambda ($tmp$$416 )  (cons $tmp$$414 $tmp$$416 #:cc cc$$116))))))))) (cc$$116 (quote ()) )))))) ((lambda _$$249  ((lambda _$$248  (begin  (set! for-each (lambda (f lst #:cc cc$$115)  (pair? lst #:cc (lambda ($tmp$$407 )  ((lambda ($tmp$$432 )  (if $tmp$$407 (car lst #:cc (lambda ($tmp$$408 )  (f $tmp$$408 #:cc (lambda ($tmp$$409 )  (cdr lst #:cc (lambda ($tmp$$410 )  (map f $tmp$$410 #:cc (lambda ($tmp$$411 )  (cons $tmp$$409 $tmp$$411 #:cc $tmp$$432))))))))) ($tmp$$432 (quote ()) ))) (lambda _$$247  (void  #:cc cc$$115)) ))))) ((lambda _$$246  ((lambda _$$245  (begin  (set! append (lambda (lst1 lst2 #:cc cc$$114)  (pair? lst1 #:cc (lambda ($tmp$$402 )  (not $tmp$$402 #:cc (lambda ($tmp$$403 )  (if $tmp$$403 (cc$$114 lst2 ) (car lst1 #:cc (lambda ($tmp$$404 )  (cdr lst1 #:cc (lambda ($tmp$$405 )  (append $tmp$$405 lst2 #:cc (lambda ($tmp$$406 )  (cons $tmp$$404 $tmp$$406 #:cc cc$$114)))))))))))))) ((lambda _$$244  ((lambda _$$243  (begin  (set! string->list (lambda (s #:cc cc$$112)  ((lambda (f )  (begin  (set! f (lambda (i #:cc cc$$113)  (string-length s #:cc (lambda ($tmp$$397 )  (< i $tmp$$397 #:cc (lambda ($tmp$$398 )  (if $tmp$$398 (string-ref s i #:cc (lambda ($tmp$$399 )  (+ i 1 #:cc (lambda ($tmp$$400 )  (f $tmp$$400 #:cc (lambda ($tmp$$401 )  (cons $tmp$$399 $tmp$$401 #:cc cc$$113))))))) (cc$$113 (quote ()) )))))))) ((lambda _$$242  ((lambda _$$241  (f 0 #:cc cc$$112)) (void) )) (void) ))) 'undefined ))) ((lambda _$$240  ((lambda _$$239  (begin  (set! apply (lambda (f l #:cc cc$$111)  (length l #:cc (lambda (len )  (= len 0 #:cc (lambda ($tmp$$382 )  (if $tmp$$382 (f  #:cc cc$$111) (= len 1 #:cc (lambda ($tmp$$383 )  (if $tmp$$383 (car l #:cc (lambda ($tmp$$384 )  (f $tmp$$384 #:cc cc$$111))) (= len 2 #:cc (lambda ($tmp$$385 )  (if $tmp$$385 (car l #:cc (lambda ($tmp$$386 )  (cadr l #:cc (lambda ($tmp$$387 )  (f $tmp$$386 $tmp$$387 #:cc cc$$111))))) (= len 3 #:cc (lambda ($tmp$$388 )  (if $tmp$$388 (car l #:cc (lambda ($tmp$$389 )  (cadr l #:cc (lambda ($tmp$$390 )  (caddr l #:cc (lambda ($tmp$$391 )  (f $tmp$$389 $tmp$$390 $tmp$$391 #:cc cc$$111))))))) (= len 4 #:cc (lambda ($tmp$$392 )  (if $tmp$$392 (car l #:cc (lambda ($tmp$$393 )  (cadr l #:cc (lambda ($tmp$$394 )  (caddr l #:cc (lambda ($tmp$$395 )  (cadddr l #:cc (lambda ($tmp$$396 )  (f $tmp$$393 $tmp$$394 $tmp$$395 $tmp$$396 #:cc cc$$111))))))))) (cc$$111 (void) )))))))))))))))))))) ((lambda _$$238  ((lambda _$$237  (begin  (set! assv (lambda (x f #:cc cc$$110)  (pair? f #:cc (lambda ($tmp$$377 )  (if $tmp$$377 (car f #:cc (lambda ($tmp$$378 )  (car $tmp$$378 #:cc (lambda ($tmp$$379 )  (eqv? $tmp$$379 x #:cc (lambda ($tmp$$380 )  (if $tmp$$380 (car f #:cc cc$$110) (cdr f #:cc (lambda ($tmp$$381 )  (assv x $tmp$$381 #:cc cc$$110)))))))))) (cc$$110 #f )))))) ((lambda _$$236  ((lambda _$$235  (begin  (set! assq (lambda (x f #:cc cc$$109)  (pair? f #:cc (lambda ($tmp$$372 )  (if $tmp$$372 (car f #:cc (lambda ($tmp$$373 )  (car $tmp$$373 #:cc (lambda ($tmp$$374 )  (eq? $tmp$$374 x #:cc (lambda ($tmp$$375 )  (if $tmp$$375 (car f #:cc cc$$109) (cdr f #:cc (lambda ($tmp$$376 )  (assv x $tmp$$376 #:cc cc$$109)))))))))) (cc$$109 #f )))))) ((lambda _$$234  ((lambda _$$233  (begin  (set! gensym-count 0) ((lambda _$$232  ((lambda _$$231  (begin  (set! gensym (lambda (name #:cc cc$$108)  (+ gensym-count 1 #:cc (lambda ($tmp$$367 )  (begin  (set! gensym-count $tmp$$367) ((lambda _$$230  ((lambda _$$229  (symbol? name #:cc (lambda ($tmp$$368 )  ((lambda ($tmp$$431 )  (if $tmp$$368 (symbol->string name #:cc $tmp$$431) ($tmp$$431 name ))) (lambda ($tmp$$369 )  (number->string gensym-count #:cc (lambda ($tmp$$370 )  (string-append $tmp$$369 "$" $tmp$$370 #:cc (lambda ($tmp$$371 )  (string->symbol $tmp$$371 #:cc cc$$108)))))) )))) (void) )) (void) )))))) ((lambda _$$228  ((lambda _$$227  (begin  (set! three-d-tagged-list? (lambda (tag lst #:cc cc$$107)  (pair? lst #:cc (lambda ($tmp$$359 )  (if $tmp$$359 (car lst #:cc (lambda ($tmp$$361 )  (eq? $tmp$$361 tag #:cc (lambda ($tmp$$360 )  (if $tmp$$360 (cc$$107 $tmp$$360 ) (car lst #:cc (lambda ($tmp$$362 )  (procedure? $tmp$$362 #:cc (lambda ($tmp$$363 )  (if $tmp$$363 (car lst #:cc (lambda ($tmp$$364 )  ($tmp$$364  #:cc (lambda ($tmp$$365 )  (initial tag #:cc (lambda ($tmp$$366 )  (equal? $tmp$$365 $tmp$$366 #:cc cc$$107))))))) (cc$$107 #f ))))))))))) (cc$$107 #f )))))) ((lambda _$$226  ((lambda _$$225  (begin  (set! tagged-list? (lambda (tag lst #:cc cc$$106)  (pair? lst #:cc (lambda ($tmp$$357 )  (if $tmp$$357 (car lst #:cc (lambda ($tmp$$358 )  (eq? $tmp$$358 tag #:cc cc$$106))) (cc$$106 #f )))))) ((lambda _$$224  ((lambda _$$223  (begin  (set! singlet? (lambda (list #:cc cc$$105)  (pair? list #:cc (lambda ($tmp$$355 )  (if $tmp$$355 (cdr list #:cc (lambda ($tmp$$356 )  (null? $tmp$$356 #:cc cc$$105))) (cc$$105 #f )))))) ((lambda _$$222  ((lambda _$$221  (begin  (set! partition-k (lambda (pred list k #:cc cc$$103)  (pair? list #:cc (lambda ($tmp$$346 )  (not $tmp$$346 #:cc (lambda ($tmp$$347 )  (if $tmp$$347 (k (quote ()) (quote ()) #:cc cc$$103) (cdr list #:cc (lambda ($tmp$$348 )  (partition-k pred $tmp$$348 (lambda (trues falses #:cc cc$$104)  (car list #:cc (lambda ($tmp$$349 )  (pred $tmp$$349 #:cc (lambda ($tmp$$350 )  (if $tmp$$350 (car list #:cc (lambda ($tmp$$351 )  (cons $tmp$$351 trues #:cc (lambda ($tmp$$352 )  (k $tmp$$352 falses #:cc cc$$104))))) (car list #:cc (lambda ($tmp$$353 )  (cons $tmp$$353 falses #:cc (lambda ($tmp$$354 )  (k trues $tmp$$354 #:cc cc$$104))))))))))) #:cc cc$$103)))))))))) ((lambda _$$220  ((lambda _$$219  (begin  (set! unzip-amap-k (lambda (amap k #:cc cc$$101)  (pair? amap #:cc (lambda ($tmp$$337 )  (not $tmp$$337 #:cc (lambda ($tmp$$338 )  (if $tmp$$338 (k (quote ()) (quote ()) #:cc cc$$101) (cdr amap #:cc (lambda ($tmp$$339 )  (unzip-amap-k $tmp$$339 (lambda (xs ys #:cc cc$$102)  (car amap #:cc (lambda ($tmp$$340 )  (car $tmp$$340 #:cc (lambda ($tmp$$341 )  (cons $tmp$$341 xs #:cc (lambda ($tmp$$342 )  (car amap #:cc (lambda ($tmp$$343 )  (cadr $tmp$$343 #:cc (lambda ($tmp$$344 )  (cons $tmp$$344 ys #:cc (lambda ($tmp$$345 )  (k $tmp$$342 $tmp$$345 #:cc cc$$102)))))))))))))) #:cc cc$$101)))))))))) ((lambda _$$218  ((lambda _$$217  (begin  (set! void (lambda ( #:cc cc$$100)  (if #f (cc$$100 #t ) (cc$$100 (void) )))) ((lambda _$$216  ((lambda _$$215  (begin  (set! define? (lambda (s-exp #:cc cc$$99)  (tagged-list? (quote define) s-exp #:cc cc$$99))) ((lambda _$$214  ((lambda _$$213  (begin  (set! define-var? (lambda (s-exp #:cc cc$$98)  (define? s-exp #:cc (lambda ($tmp$$335 )  (if $tmp$$335 (cadr s-exp #:cc (lambda ($tmp$$336 )  (symbol? $tmp$$336 #:cc cc$$98))) (cc$$98 #f )))))) ((lambda _$$212  ((lambda _$$211  (begin  (set! define-fun? (lambda (s-exp #:cc cc$$97)  (define? s-exp #:cc (lambda ($tmp$$333 )  (if $tmp$$333 (cadr s-exp #:cc (lambda ($tmp$$334 )  (pair? $tmp$$334 #:cc cc$$97))) (cc$$97 #f )))))) ((lambda _$$210  ((lambda _$$209  (begin  (set! define->var (lambda (s-exp #:cc cc$$96)  (define-var? s-exp #:cc (lambda ($tmp$$331 )  (if $tmp$$331 (cadr s-exp #:cc cc$$96) (define-fun? s-exp #:cc (lambda ($tmp$$332 )  (if $tmp$$332 (caadr s-exp #:cc cc$$96) (error "unknown define!" #:cc cc$$96))))))))) ((lambda _$$208  ((lambda _$$207  (begin  (set! define->exp (lambda (s-exp #:cc cc$$95)  (define-var? s-exp #:cc (lambda ($tmp$$326 )  (if $tmp$$326 (caddr s-exp #:cc cc$$95) (define-fun? s-exp #:cc (lambda ($tmp$$327 )  (if $tmp$$327 (cdadr s-exp #:cc (lambda ($tmp$$328 )  (cddr s-exp #:cc (lambda ($tmp$$329 )  (cons $tmp$$328 $tmp$$329 #:cc (lambda ($tmp$$330 )  (cons three-d-lambda $tmp$$330 #:cc cc$$95))))))) (cc$$95 (void) ))))))))) ((lambda _$$206  ((lambda _$$205  (begin  (set! if? (lambda (s-exp #:cc cc$$94)  (three-d-tagged-list? (quote if) s-exp #:cc cc$$94))) ((lambda _$$204  ((lambda _$$203  (begin  (set! if-single? (lambda (s-exp #:cc cc$$93)  (if? s-exp #:cc (lambda ($tmp$$324 )  (if $tmp$$324 (cdddr s-exp #:cc (lambda ($tmp$$325 )  (null? $tmp$$325 #:cc cc$$93))) (cc$$93 #f )))))) ((lambda _$$202  ((lambda _$$201  (begin  (set! if->cond (lambda (s-exp #:cc cc$$92)  (cadr s-exp #:cc cc$$92))) ((lambda _$$200  ((lambda _$$199  (begin  (set! if->true (lambda (s-exp #:cc cc$$91)  (caddr s-exp #:cc cc$$91))) ((lambda _$$198  ((lambda _$$197  (begin  (set! if->false (lambda (s-exp #:cc cc$$90)  (cadddr s-exp #:cc cc$$90))) ((lambda _$$196  ((lambda _$$195  (begin  (set! quote? (lambda (s-exp #:cc cc$$89)  (three-d-tagged-list? (quote quote) s-exp #:cc cc$$89))) ((lambda _$$194  ((lambda _$$193  (begin  (set! quote->text (lambda (s-exp #:cc cc$$88)  (cadr s-exp #:cc cc$$88))) ((lambda _$$192  ((lambda _$$191  (begin  (set! lambda? (lambda (s-exp #:cc cc$$87)  (three-d-tagged-list? (quote lambda) s-exp #:cc cc$$87))) ((lambda _$$190  ((lambda _$$189  (begin  (set! lambda-multi? (lambda (s-exp #:cc cc$$86)  (lambda? s-exp #:cc (lambda ($tmp$$322 )  (if $tmp$$322 (cadr s-exp #:cc (lambda ($tmp$$323 )  (symbol? $tmp$$323 #:cc cc$$86))) (cc$$86 #f )))))) ((lambda _$$188  ((lambda _$$187  (begin  (set! lambda->formals (lambda (s-exp #:cc cc$$85)  (cadr s-exp #:cc cc$$85))) ((lambda _$$186  ((lambda _$$185  (begin  (set! lambda->body (lambda (s-exp #:cc cc$$84)  (cddr s-exp #:cc cc$$84))) ((lambda _$$184  ((lambda _$$183  (begin  (set! lambda->body-as-exp (lambda (s-exp #:cc cc$$83)  (cddr s-exp #:cc (lambda ($tmp$$321 )  (make-begin $tmp$$321 #:cc cc$$83))))) ((lambda _$$182  ((lambda _$$181  (begin  (set! begin? (lambda (s-exp #:cc cc$$82)  (three-d-tagged-list? (quote begin) s-exp #:cc cc$$82))) ((lambda _$$180  ((lambda _$$179  (begin  (set! begin->body (lambda (s-exp #:cc cc$$81)  (cdr s-exp #:cc cc$$81))) ((lambda _$$178  ((lambda _$$177  (begin  (set! make-begin (lambda (exps #:cc cc$$80)  (singlet? exps #:cc (lambda ($tmp$$320 )  (if $tmp$$320 (car exps #:cc cc$$80) (cons three-d-begin exps #:cc cc$$80)))))) ((lambda _$$176  ((lambda _$$175  (begin  (set! app? (lambda (s-exp #:cc cc$$79)  (pair? s-exp #:cc cc$$79))) ((lambda _$$174  ((lambda _$$173  (begin  (set! app->fun (lambda (s-exp #:cc cc$$78)  (car s-exp #:cc cc$$78))) ((lambda _$$172  ((lambda _$$171  (begin  (set! app->args (lambda (s-exp #:cc cc$$77)  (cdr s-exp #:cc cc$$77))) ((lambda _$$170  ((lambda _$$169  (begin  (set! binding->var (lambda (binding #:cc cc$$76)  (car binding #:cc cc$$76))) ((lambda _$$168  ((lambda _$$167  (begin  (set! binding->exp (lambda (binding #:cc cc$$75)  (cadr binding #:cc cc$$75))) ((lambda _$$166  ((lambda _$$165  (begin  (set! letrec? (lambda (s-exp #:cc cc$$74)  (three-d-tagged-list? (quote letrec) s-exp #:cc cc$$74))) ((lambda _$$164  ((lambda _$$163  (begin  (set! letrec->bindings (lambda (s-exp #:cc cc$$73)  (cadr s-exp #:cc cc$$73))) ((lambda _$$162  ((lambda _$$161  (begin  (set! letrec->body (lambda (s-exp #:cc cc$$72)  (cddr s-exp #:cc cc$$72))) ((lambda _$$160  ((lambda _$$159  (begin  (set! letrec->body-as-exp (lambda (s-exp #:cc cc$$71)  (letrec->body s-exp #:cc (lambda ($tmp$$319 )  (make-begin $tmp$$319 #:cc cc$$71))))) ((lambda _$$158  ((lambda _$$157  (begin  (set! let? (lambda (s-exp #:cc cc$$70)  (three-d-tagged-list? (quote let) s-exp #:cc cc$$70))) ((lambda _$$156  ((lambda _$$155  (begin  (set! let->bindings (lambda (s-exp #:cc cc$$69)  (cadr s-exp #:cc cc$$69))) ((lambda _$$154  ((lambda _$$153  (begin  (set! let->body (lambda (s-exp #:cc cc$$68)  (cddr s-exp #:cc cc$$68))) ((lambda _$$152  ((lambda _$$151  (begin  (set! let->body-as-exp (lambda (s-exp #:cc cc$$67)  (let->body s-exp #:cc (lambda ($tmp$$318 )  (make-begin $tmp$$318 #:cc cc$$67))))) ((lambda _$$150  ((lambda _$$149  (begin  (set! let*? (lambda (s-exp #:cc cc$$66)  (three-d-tagged-list? (quote let*) s-exp #:cc cc$$66))) ((lambda _$$148  ((lambda _$$147  (begin  (set! let*->bindings (lambda (s-exp #:cc cc$$65)  (cadr s-exp #:cc cc$$65))) ((lambda _$$146  ((lambda _$$145  (begin  (set! let*->body (lambda (s-exp #:cc cc$$64)  (cddr s-exp #:cc cc$$64))) ((lambda _$$144  ((lambda _$$143  (begin  (set! let*->body-as-exp (lambda (s-exp #:cc cc$$63)  (let*->body s-exp #:cc (lambda ($tmp$$317 )  (make-begin $tmp$$317 #:cc cc$$63))))) ((lambda _$$142  ((lambda _$$141  (begin  (set! or? (lambda (s-exp #:cc cc$$62)  (three-d-tagged-list? (quote or) s-exp #:cc cc$$62))) ((lambda _$$140  ((lambda _$$139  (begin  (set! or->exps (lambda (s-exp #:cc cc$$61)  (cdr s-exp #:cc cc$$61))) ((lambda _$$138  ((lambda _$$137  (begin  (set! make-or (lambda (exps #:cc cc$$60)  (null? exps #:cc (lambda ($tmp$$315 )  (if $tmp$$315 (cc$$60 #f ) (singlet? exps #:cc (lambda ($tmp$$316 )  (if $tmp$$316 (car exps #:cc cc$$60) (cons (quote or) exps #:cc cc$$60))))))))) ((lambda _$$136  ((lambda _$$135  (begin  (set! and? (lambda (s-exp #:cc cc$$59)  (three-d-tagged-list? (quote and) s-exp #:cc cc$$59))) ((lambda _$$134  ((lambda _$$133  (begin  (set! and->exps (lambda (s-exp #:cc cc$$58)  (cdr s-exp #:cc cc$$58))) ((lambda _$$132  ((lambda _$$131  (begin  (set! make-and (lambda (exps #:cc cc$$57)  (null? exps #:cc (lambda ($tmp$$313 )  (if $tmp$$313 (cc$$57 #t ) (singlet? exps #:cc (lambda ($tmp$$314 )  (if $tmp$$314 (car exps #:cc cc$$57) (cons (quote and) exps #:cc cc$$57))))))))) ((lambda _$$130  ((lambda _$$129  (begin  (set! cond? (lambda (s-exp #:cc cc$$56)  (three-d-tagged-list? (quote cond) s-exp #:cc cc$$56))) ((lambda _$$128  ((lambda _$$127  (begin  (set! cond->clauses (lambda (s-exp #:cc cc$$55)  (cdr s-exp #:cc cc$$55))) ((lambda _$$126  ((lambda _$$125  (begin  (set! arrow-clause? (lambda (clause #:cc cc$$54)  (pair? clause #:cc (lambda ($tmp$$309 )  (if $tmp$$309 (cdr clause #:cc (lambda ($tmp$$310 )  (pair? $tmp$$310 #:cc (lambda ($tmp$$311 )  (if $tmp$$311 (cadr clause #:cc (lambda ($tmp$$312 )  (eq? $tmp$$312 (quote =>) #:cc cc$$54))) (cc$$54 #f )))))) (cc$$54 #f )))))) ((lambda _$$124  ((lambda _$$123  (begin  (set! else-clause? (lambda (clause #:cc cc$$53)  (three-d-tagged-list? (quote else) clause #:cc cc$$53))) ((lambda _$$122  ((lambda _$$121  (begin  (set! cond-clause->exp (lambda (clause #:cc cc$$52)  (singlet? clause #:cc (lambda ($tmp$$305 )  (if $tmp$$305 (car clause #:cc cc$$52) (else-clause? clause #:cc (lambda ($tmp$$306 )  (if $tmp$$306 (cadr clause #:cc cc$$52) (arrow-clause? clause #:cc (lambda ($tmp$$307 )  (if $tmp$$307 (caddr clause #:cc cc$$52) (cdr clause #:cc (lambda ($tmp$$308 )  (make-begin $tmp$$308 #:cc cc$$52)))))))))))))) ((lambda _$$120  ((lambda _$$119  (begin  (set! cond-clause->test (lambda (clause #:cc cc$$51)  (singlet? clause #:cc (lambda ($tmp$$302 )  (if $tmp$$302 (car clause #:cc cc$$51) (else-clause? clause #:cc (lambda ($tmp$$303 )  (if $tmp$$303 (cc$$51 #t ) (arrow-clause? clause #:cc (lambda ($tmp$$304 )  (if $tmp$$304 (car clause #:cc cc$$51) (car clause #:cc cc$$51)))))))))))) ((lambda _$$118  ((lambda _$$117  (begin  (set! set!? (lambda (s-exp #:cc cc$$50)  (three-d-tagged-list? (quote set!) s-exp #:cc cc$$50))) ((lambda _$$116  ((lambda _$$115  (begin  (set! set!->var (lambda (s-exp #:cc cc$$49)  (cadr s-exp #:cc cc$$49))) ((lambda _$$114  ((lambda _$$113  (begin  (set! set!->exp (lambda (s-exp #:cc cc$$48)  (caddr s-exp #:cc cc$$48))) ((lambda _$$112  ((lambda _$$111  (begin  (set! macro? (lambda (s-exp #:cc cc$$47)  (three-d-tagged-list? (quote macro) s-exp #:cc cc$$47))) ((lambda _$$110  ((lambda _$$109  (begin  (set! macro->proc (lambda (s-exp #:cc cc$$46)  (cadr s-exp #:cc cc$$46))) ((lambda _$$108  ((lambda _$$107  (begin  (set! syntax-primitive? (lambda (value #:cc cc$$45)  (three-d-tagged-list? (quote syntax-primitive) value #:cc cc$$45))) ((lambda _$$106  ((lambda _$$105  (begin  (set! syntax-primitive->eval (lambda (value #:cc cc$$44)  (cadr value #:cc cc$$44))) ((lambda _$$104  ((lambda _$$103  (begin  (set! def->binding (lambda (def #:cc cc$$43)  (define->var def #:cc (lambda ($tmp$$299 )  (define->exp def #:cc (lambda ($tmp$$300 )  (cons $tmp$$300 (quote ()) #:cc (lambda ($tmp$$301 )  (cons $tmp$$299 $tmp$$301 #:cc cc$$43))))))))) ((lambda _$$102  ((lambda _$$101  (begin  (set! body->letrec (lambda (decs #:cc cc$$41)  (partition-k define? decs (lambda (defs exps #:cc cc$$42)  (null? defs #:cc (lambda ($tmp$$295 )  (if $tmp$$295 (make-begin exps #:cc cc$$42) (map def->binding defs #:cc (lambda (bindings )  (make-begin exps #:cc (lambda ($tmp$$296 )  (cons $tmp$$296 (quote ()) #:cc (lambda ($tmp$$297 )  (cons bindings $tmp$$297 #:cc (lambda ($tmp$$298 )  (cons three-d-letrec $tmp$$298 #:cc cc$$42))))))))))))) #:cc cc$$41))) ((lambda _$$100  ((lambda _$$99  (begin  (set! letrec->lets+sets (lambda (exp #:cc cc$$38)  (letrec? exp #:cc (lambda ($tmp$$280 )  (not $tmp$$280 #:cc (lambda ($tmp$$281 )  (if $tmp$$281 (cc$$38 exp ) (letrec->bindings exp #:cc (lambda ($tmp$$284 )  (map (lambda (binding #:cc cc$$40)  (binding->var binding #:cc (lambda ($tmp$$282 )  (cons #f (quote ()) #:cc (lambda ($tmp$$283 )  (cons $tmp$$282 $tmp$$283 #:cc cc$$40)))))) $tmp$$284 #:cc (lambda (bindings )  (letrec->bindings exp #:cc (lambda ($tmp$$289 )  (map (lambda (binding #:cc cc$$39)  (binding->var binding #:cc (lambda ($tmp$$285 )  (binding->exp binding #:cc (lambda ($tmp$$286 )  (cons $tmp$$286 (quote ()) #:cc (lambda ($tmp$$287 )  (cons $tmp$$285 $tmp$$287 #:cc (lambda ($tmp$$288 )  (cons three-d-set! $tmp$$288 #:cc cc$$39)))))))))) $tmp$$289 #:cc (lambda (sets )  (letrec->body exp #:cc (lambda ($tmp$$290 )  (append sets $tmp$$290 #:cc (lambda ($tmp$$291 )  (make-begin $tmp$$291 #:cc (lambda ($tmp$$292 )  (cons $tmp$$292 (quote ()) #:cc (lambda ($tmp$$293 )  (cons bindings $tmp$$293 #:cc (lambda ($tmp$$294 )  (cons three-d-let $tmp$$294 #:cc cc$$38)))))))))))))))))))))))))) ((lambda _$$98  ((lambda _$$97  (begin  (set! cond->if (lambda (cond-exp #:cc cc$$37)  (cond? cond-exp #:cc (lambda ($tmp$$277 )  (not $tmp$$277 #:cc (lambda ($tmp$$278 )  (if $tmp$$278 (cc$$37 cond-exp ) (cond->clauses cond-exp #:cc (lambda ($tmp$$279 )  (cond-clauses->if $tmp$$279 #:cc cc$$37)))))))))) ((lambda _$$96  ((lambda _$$95  (begin  (set! cond-clauses->if (lambda (clauses #:cc cc$$36)  (null? clauses #:cc (lambda ($tmp$$264 )  (if $tmp$$264 (cons (quote void) (quote ()) #:cc cc$$36) (car clauses #:cc (lambda (clause )  (singlet? clause #:cc (lambda ($tmp$$265 )  (if $tmp$$265 (cdr clauses #:cc (lambda ($tmp$$266 )  (cond-clauses->if $tmp$$266 #:cc (lambda ($tmp$$267 )  (cons clause $tmp$$267 #:cc (lambda ($tmp$$268 )  (make-or $tmp$$268 #:cc cc$$36))))))) (else-clause? clause #:cc (lambda ($tmp$$269 )  (if $tmp$$269 (cond-clause->exp clause #:cc cc$$36) (cond-clause->test clause #:cc (lambda ($tmp$$270 )  (cond-clause->exp clause #:cc (lambda ($tmp$$271 )  (cdr clauses #:cc (lambda ($tmp$$272 )  (cond-clauses->if $tmp$$272 #:cc (lambda ($tmp$$273 )  (cons $tmp$$273 (quote ()) #:cc (lambda ($tmp$$274 )  (cons $tmp$$271 $tmp$$274 #:cc (lambda ($tmp$$275 )  (cons $tmp$$270 $tmp$$275 #:cc (lambda ($tmp$$276 )  (cons three-d-if $tmp$$276 #:cc cc$$36)))))))))))))))))))))))))))) ((lambda _$$94  ((lambda _$$93  (begin  (set! and->if (lambda (exp #:cc cc$$35)  (and? exp #:cc (lambda ($tmp$$253 )  (not $tmp$$253 #:cc (lambda ($tmp$$254 )  (if $tmp$$254 (cc$$35 exp ) (and->exps exp #:cc (lambda (exps )  (null? exps #:cc (lambda ($tmp$$255 )  (if $tmp$$255 (cc$$35 #t ) (singlet? exps #:cc (lambda ($tmp$$256 )  (if $tmp$$256 (car exps #:cc cc$$35) (car exps #:cc (lambda ($tmp$$257 )  (cdr exps #:cc (lambda ($tmp$$258 )  (cons (quote and) $tmp$$258 #:cc (lambda ($tmp$$259 )  (and->if $tmp$$259 #:cc (lambda ($tmp$$260 )  (cons #f (quote ()) #:cc (lambda ($tmp$$261 )  (cons $tmp$$260 $tmp$$261 #:cc (lambda ($tmp$$262 )  (cons $tmp$$257 $tmp$$262 #:cc (lambda ($tmp$$263 )  (cons three-d-if $tmp$$263 #:cc cc$$35)))))))))))))))))))))))))))))) ((lambda _$$92  ((lambda _$$91  (begin  (set! or->if (lambda (exp #:cc cc$$34)  (or? exp #:cc (lambda ($tmp$$236 )  (not $tmp$$236 #:cc (lambda ($tmp$$237 )  (if $tmp$$237 (cc$$34 exp ) (or->exps exp #:cc (lambda (exps )  (null? exps #:cc (lambda ($tmp$$238 )  (if $tmp$$238 (cc$$34 #f ) (singlet? exps #:cc (lambda ($tmp$$239 )  (if $tmp$$239 (car exps #:cc cc$$34) (gensym "or-tmp" #:cc (lambda ($tmp )  (car exps #:cc (lambda ($tmp$$240 )  (cons $tmp$$240 (quote ()) #:cc (lambda ($tmp$$241 )  (cons $tmp $tmp$$241 #:cc (lambda ($tmp$$242 )  (cons $tmp$$242 (quote ()) #:cc (lambda ($tmp$$243 )  (cdr exps #:cc (lambda ($tmp$$244 )  (cons three-d-or $tmp$$244 #:cc (lambda ($tmp$$245 )  (or->if $tmp$$245 #:cc (lambda ($tmp$$246 )  (cons $tmp$$246 (quote ()) #:cc (lambda ($tmp$$247 )  (cons $tmp $tmp$$247 #:cc (lambda ($tmp$$248 )  (cons $tmp $tmp$$248 #:cc (lambda ($tmp$$249 )  (cons three-d-if $tmp$$249 #:cc (lambda ($tmp$$250 )  (cons $tmp$$250 (quote ()) #:cc (lambda ($tmp$$251 )  (cons $tmp$$243 $tmp$$251 #:cc (lambda ($tmp$$252 )  (cons three-d-let $tmp$$252 #:cc cc$$34)))))))))))))))))))))))))))))))))))))))))))) ((lambda _$$90  ((lambda _$$89  (begin  (set! let*->let (lambda (exp #:cc cc$$33)  (let*? exp #:cc (lambda ($tmp$$232 )  (not $tmp$$232 #:cc (lambda ($tmp$$233 )  (if $tmp$$233 (cc$$33 exp ) (let*->bindings exp #:cc (lambda ($tmp$$234 )  (let*->body exp #:cc (lambda ($tmp$$235 )  (let*-bindings->let $tmp$$234 $tmp$$235 #:cc cc$$33)))))))))))) ((lambda _$$88  ((lambda _$$87  (begin  (set! let*-bindings->let (lambda (bindings body #:cc cc$$32)  (singlet? bindings #:cc (lambda ($tmp$$221 )  (if $tmp$$221 (car bindings #:cc (lambda ($tmp$$222 )  (cons $tmp$$222 (quote ()) #:cc (lambda ($tmp$$223 )  (cons $tmp$$223 body #:cc (lambda ($tmp$$224 )  (cons three-d-let $tmp$$224 #:cc cc$$32))))))) (null? bindings #:cc (lambda ($tmp$$225 )  (if $tmp$$225 (make-begin body #:cc cc$$32) (car bindings #:cc (lambda ($tmp$$226 )  (cons $tmp$$226 (quote ()) #:cc (lambda ($tmp$$227 )  (cdr bindings #:cc (lambda ($tmp$$228 )  (let*-bindings->let $tmp$$228 body #:cc (lambda ($tmp$$229 )  (cons $tmp$$229 (quote ()) #:cc (lambda ($tmp$$230 )  (cons $tmp$$227 $tmp$$230 #:cc (lambda ($tmp$$231 )  (cons three-d-let $tmp$$231 #:cc cc$$32))))))))))))))))))))) ((lambda _$$86  ((lambda _$$85  (begin  (set! let->app (lambda (exp #:cc cc$$30)  (let? exp #:cc (lambda ($tmp$$215 )  (not $tmp$$215 #:cc (lambda ($tmp$$216 )  (if $tmp$$216 (cc$$30 exp ) (let->bindings exp #:cc (lambda ($tmp$$217 )  (unzip-amap-k $tmp$$217 (lambda (vars exps #:cc cc$$31)  (let->body exp #:cc (lambda ($tmp$$218 )  (cons vars $tmp$$218 #:cc (lambda ($tmp$$219 )  (cons three-d-lambda $tmp$$219 #:cc (lambda ($tmp$$220 )  (cons $tmp$$220 exps #:cc cc$$31)))))))) #:cc cc$$30)))))))))) ((lambda _$$84  ((lambda _$$83  (begin  (set! eval (lambda (exp env #:cc cc$$29)  (symbol? exp #:cc (lambda ($tmp$$207 )  (if $tmp$$207 (env-lookup env exp #:cc cc$$29) (number? exp #:cc (lambda ($tmp$$208 )  (if $tmp$$208 (cc$$29 exp ) (boolean? exp #:cc (lambda ($tmp$$209 )  (if $tmp$$209 (cc$$29 exp ) (string? exp #:cc (lambda ($tmp$$210 )  (if $tmp$$210 (cc$$29 exp ) (procedure? exp #:cc (lambda ($tmp$$211 )  (if $tmp$$211 (exp  #:cc cc$$29) (app? exp #:cc (lambda ($tmp$$212 )  (if $tmp$$212 (app->fun exp #:cc (lambda ($tmp$$213 )  (eval $tmp$$213 env #:cc (lambda ($tmp$$214 )  (perform-apply $tmp$$214 exp env #:cc cc$$29))))) (cc$$29 (void) ))))))))))))))))))))) ((lambda _$$82  ((lambda _$$81  (begin  (set! eval-with (lambda (env #:cc cc$$27)  (cc$$27 (lambda (exp #:cc cc$$28)  (eval exp env #:cc cc$$28)) ))) ((lambda _$$80  ((lambda _$$79  (begin  (set! eval* (lambda (exps env #:cc cc$$26)  (eval-with env #:cc (lambda ($tmp$$206 )  (map $tmp$$206 exps #:cc cc$$26))))) ((lambda _$$78  ((lambda _$$77  (begin  (set! eval-quote (lambda (exp env #:cc cc$$25)  (quote->text exp #:cc cc$$25))) ((lambda _$$76  ((lambda _$$75  (begin  (set! eval-if (lambda (exp env #:cc cc$$24)  (if-single? exp #:cc (lambda ($tmp$$198 )  (if $tmp$$198 (if->cond exp #:cc (lambda ($tmp$$199 )  (eval $tmp$$199 env #:cc (lambda ($tmp$$200 )  (if $tmp$$200 (if->true exp #:cc (lambda ($tmp$$201 )  (eval $tmp$$201 env #:cc cc$$24))) (cc$$24 (void) )))))) (if->cond exp #:cc (lambda ($tmp$$202 )  (eval $tmp$$202 env #:cc (lambda ($tmp$$203 )  (if $tmp$$203 (if->true exp #:cc (lambda ($tmp$$204 )  (eval $tmp$$204 env #:cc cc$$24))) (if->false exp #:cc (lambda ($tmp$$205 )  (eval $tmp$$205 env #:cc cc$$24))))))))))))) ((lambda _$$74  ((lambda _$$73  (begin  (set! eval-cond (lambda (exp env #:cc cc$$23)  (cond->if exp #:cc (lambda ($tmp$$197 )  (eval $tmp$$197 env #:cc cc$$23))))) ((lambda _$$72  ((lambda _$$71  (begin  (set! eval-and (lambda (exp env #:cc cc$$22)  (and->if exp #:cc (lambda ($tmp$$196 )  (eval $tmp$$196 env #:cc cc$$22))))) ((lambda _$$70  ((lambda _$$69  (begin  (set! eval-or (lambda (exp env #:cc cc$$21)  (or->if exp #:cc (lambda ($tmp$$195 )  (eval $tmp$$195 env #:cc cc$$21))))) ((lambda _$$68  ((lambda _$$67  (begin  (set! eval-let (lambda (exp env #:cc cc$$20)  (let->app exp #:cc (lambda ($tmp$$194 )  (eval $tmp$$194 env #:cc cc$$20))))) ((lambda _$$66  ((lambda _$$65  (begin  (set! eval-let* (lambda (exp env #:cc cc$$19)  (let*->let exp #:cc (lambda ($tmp$$193 )  (eval $tmp$$193 env #:cc cc$$19))))) ((lambda _$$64  ((lambda _$$63  (begin  (set! eval-letrec (lambda (exp env #:cc cc$$18)  (letrec->lets+sets exp #:cc (lambda ($tmp$$192 )  (eval $tmp$$192 env #:cc cc$$18))))) ((lambda _$$62  ((lambda _$$61  (begin  (set! eval-begin (lambda (exp env #:cc cc$$17)  (begin->body exp #:cc (lambda ($tmp$$187 )  (body->letrec $tmp$$187 #:cc (lambda (simplified )  (begin? simplified #:cc (lambda ($tmp$$188 )  (if $tmp$$188 (begin->body exp #:cc (lambda ($tmp$$189 )  (eval* $tmp$$189 env #:cc (lambda ($tmp$$190 )  (reverse $tmp$$190 #:cc (lambda ($tmp$$191 )  (car $tmp$$191 #:cc cc$$17))))))) (eval simplified env #:cc cc$$17)))))))))) ((lambda _$$60  ((lambda _$$59  (begin  (set! eval-set! (lambda (exp env #:cc cc$$16)  (set!->var exp #:cc (lambda ($tmp$$184 )  (set!->exp exp #:cc (lambda ($tmp$$185 )  (eval $tmp$$185 env #:cc (lambda ($tmp$$186 )  (env-set! env $tmp$$184 $tmp$$186 #:cc cc$$16))))))))) ((lambda _$$58  ((lambda _$$57  (begin  (set! eval-lambda (lambda (exp env #:cc cc$$14)  (lambda->formals exp #:cc (lambda (formals )  (cc$$14 (lambda (#:cc cc$$15 . args)  (symbol? formals #:cc (lambda ($tmp$$179 )  (if $tmp$$179 (lambda->body-as-exp exp #:cc (lambda ($tmp$$180 )  (env-extend env formals args #:cc (lambda ($tmp$$181 )  (eval $tmp$$180 $tmp$$181 #:cc cc$$15))))) (lambda->body-as-exp exp #:cc (lambda ($tmp$$182 )  (env-extend* env formals args #:cc (lambda ($tmp$$183 )  (eval $tmp$$182 $tmp$$183 #:cc cc$$15))))))))) ))))) ((lambda _$$56  ((lambda _$$55  (begin  (set! eval-macro (lambda (exp env #:cc cc$$13)  (macro->proc exp #:cc (lambda ($tmp$$176 )  (eval $tmp$$176 env #:cc (lambda ($tmp$$177 )  (cons $tmp$$177 (quote ()) #:cc (lambda ($tmp$$178 )  (cons (quote macro) $tmp$$178 #:cc cc$$13))))))))) ((lambda _$$54  ((lambda _$$53  (begin  (set! env-lookup (lambda (env var #:cc cc$$12)  (env var #f (quote unused) #:cc (lambda (value )  (cc$$12 value ))))) ((lambda _$$52  ((lambda _$$51  (begin  (set! env-set! (lambda (env var value #:cc cc$$11)  (env var #t value #:cc cc$$11))) ((lambda _$$50  ((lambda _$$49  (begin  (set! env-extend (lambda (env var value #:cc cc$$9)  (cc$$9 (lambda (seek-var modify? value! #:cc cc$$10)  (eq? var seek-var #:cc (lambda ($tmp$$175 )  (if $tmp$$175 (if modify? (begin  (set! value value!) ((lambda _$$48  (cc$$10 (void) )) (void) )) (cc$$10 value )) (env seek-var modify? value! #:cc cc$$10))))) ))) ((lambda _$$47  ((lambda _$$46  (begin  (set! env-extend* (lambda (env vars values #:cc cc$$8)  (pair? vars #:cc (lambda ($tmp$$169 )  (if $tmp$$169 (car vars #:cc (lambda ($tmp$$170 )  (car values #:cc (lambda ($tmp$$171 )  (env-extend env $tmp$$170 $tmp$$171 #:cc (lambda ($tmp$$172 )  (cdr vars #:cc (lambda ($tmp$$173 )  (cdr values #:cc (lambda ($tmp$$174 )  (env-extend* $tmp$$172 $tmp$$173 $tmp$$174 #:cc cc$$8))))))))))) (cc$$8 env )))))) ((lambda _$$45  ((lambda _$$44  (begin  (set! empty-env (lambda (var modify? value! #:cc cc$$7)  ((lambda ($tmp$$430 )  (if modify? (display "error: cannot modify undefined variable: " #:cc (lambda _$$42  (display var #:cc (lambda _$$41  (display " with " #:cc (lambda _$$40  (display value! #:cc $tmp$$430))))))) (display "error: cannot look up undefined variable: " #:cc (lambda _$$43  (display var #:cc $tmp$$430))))) (lambda _$$39  (newline  #:cc (lambda _$$38  (error  #:cc cc$$7)))) ))) ((lambda _$$37  ((lambda _$$36  (cons apply (quote ()) #:cc (lambda ($tmp$$37 )  (cons (quote apply) $tmp$$37 #:cc (lambda ($tmp$$38 )  (cons + (quote ()) #:cc (lambda ($tmp$$39 )  (cons (quote +) $tmp$$39 #:cc (lambda ($tmp$$40 )  (cons not (quote ()) #:cc (lambda ($tmp$$41 )  (cons (quote not) $tmp$$41 #:cc (lambda ($tmp$$42 )  (cons display (quote ()) #:cc (lambda ($tmp$$43 )  (cons (quote display) $tmp$$43 #:cc (lambda ($tmp$$44 )  (cons newline (quote ()) #:cc (lambda ($tmp$$45 )  (cons (quote newline) $tmp$$45 #:cc (lambda ($tmp$$46 )  (cons cons (quote ()) #:cc (lambda ($tmp$$47 )  (cons (quote cons) $tmp$$47 #:cc (lambda ($tmp$$48 )  (cons car (quote ()) #:cc (lambda ($tmp$$49 )  (cons (quote car) $tmp$$49 #:cc (lambda ($tmp$$50 )  (cons cdr (quote ()) #:cc (lambda ($tmp$$51 )  (cons (quote cdr) $tmp$$51 #:cc (lambda ($tmp$$52 )  (cons cadr (quote ()) #:cc (lambda ($tmp$$53 )  (cons (quote cadr) $tmp$$53 #:cc (lambda ($tmp$$54 )  (cons caadr (quote ()) #:cc (lambda ($tmp$$55 )  (cons (quote caadr) $tmp$$55 #:cc (lambda ($tmp$$56 )  (cons cadar (quote ()) #:cc (lambda ($tmp$$57 )  (cons (quote cadar) $tmp$$57 #:cc (lambda ($tmp$$58 )  (cons cddr (quote ()) #:cc (lambda ($tmp$$59 )  (cons (quote cddr) $tmp$$59 #:cc (lambda ($tmp$$60 )  (cons cdddr (quote ()) #:cc (lambda ($tmp$$61 )  (cons (quote cdddr) $tmp$$61 #:cc (lambda ($tmp$$62 )  (cons null? (quote ()) #:cc (lambda ($tmp$$63 )  (cons (quote null?) $tmp$$63 #:cc (lambda ($tmp$$64 )  (cons pair? (quote ()) #:cc (lambda ($tmp$$65 )  (cons (quote pair?) $tmp$$65 #:cc (lambda ($tmp$$66 )  (cons list? (quote ()) #:cc (lambda ($tmp$$67 )  (cons (quote list?) $tmp$$67 #:cc (lambda ($tmp$$68 )  (cons number? (quote ()) #:cc (lambda ($tmp$$69 )  (cons (quote number?) $tmp$$69 #:cc (lambda ($tmp$$70 )  (cons string? (quote ()) #:cc (lambda ($tmp$$71 )  (cons (quote string?) $tmp$$71 #:cc (lambda ($tmp$$72 )  (cons symbol? (quote ()) #:cc (lambda ($tmp$$73 )  (cons (quote symbol?) $tmp$$73 #:cc (lambda ($tmp$$74 )  (cons procedure? (quote ()) #:cc (lambda ($tmp$$75 )  (cons (quote procedure?) $tmp$$75 #:cc (lambda ($tmp$$76 )  (cons eq? (quote ()) #:cc (lambda ($tmp$$77 )  (cons (quote eq?) $tmp$$77 #:cc (lambda ($tmp$$78 )  (cons = (quote ()) #:cc (lambda ($tmp$$79 )  (cons (quote =) $tmp$$79 #:cc (lambda ($tmp$$80 )  (cons gensym (quote ()) #:cc (lambda ($tmp$$81 )  (cons (quote gensym) $tmp$$81 #:cc (lambda ($tmp$$82 )  (cons void (quote ()) #:cc (lambda ($tmp$$83 )  (cons (quote void) $tmp$$83 #:cc (lambda ($tmp$$84 )  (cons eval-quote (quote ()) #:cc (lambda ($tmp$$85 )  (cons (quote syntax-primitive) $tmp$$85 #:cc (lambda ($tmp$$86 )  (cons $tmp$$86 (quote ()) #:cc (lambda ($tmp$$87 )  (cons (quote quote) $tmp$$87 #:cc (lambda ($tmp$$88 )  (cons eval-if (quote ()) #:cc (lambda ($tmp$$89 )  (cons (quote syntax-primitive) $tmp$$89 #:cc (lambda ($tmp$$90 )  (cons $tmp$$90 (quote ()) #:cc (lambda ($tmp$$91 )  (cons (quote if) $tmp$$91 #:cc (lambda ($tmp$$92 )  (cons eval-cond (quote ()) #:cc (lambda ($tmp$$93 )  (cons (quote syntax-primitive) $tmp$$93 #:cc (lambda ($tmp$$94 )  (cons $tmp$$94 (quote ()) #:cc (lambda ($tmp$$95 )  (cons (quote cond) $tmp$$95 #:cc (lambda ($tmp$$96 )  (cons eval-and (quote ()) #:cc (lambda ($tmp$$97 )  (cons (quote syntax-primitive) $tmp$$97 #:cc (lambda ($tmp$$98 )  (cons $tmp$$98 (quote ()) #:cc (lambda ($tmp$$99 )  (cons (quote and) $tmp$$99 #:cc (lambda ($tmp$$100 )  (cons eval-or (quote ()) #:cc (lambda ($tmp$$101 )  (cons (quote syntax-primitive) $tmp$$101 #:cc (lambda ($tmp$$102 )  (cons $tmp$$102 (quote ()) #:cc (lambda ($tmp$$103 )  (cons (quote or) $tmp$$103 #:cc (lambda ($tmp$$104 )  (cons eval-let (quote ()) #:cc (lambda ($tmp$$105 )  (cons (quote syntax-primitive) $tmp$$105 #:cc (lambda ($tmp$$106 )  (cons $tmp$$106 (quote ()) #:cc (lambda ($tmp$$107 )  (cons (quote let) $tmp$$107 #:cc (lambda ($tmp$$108 )  (cons eval-let* (quote ()) #:cc (lambda ($tmp$$109 )  (cons (quote syntax-primitive) $tmp$$109 #:cc (lambda ($tmp$$110 )  (cons $tmp$$110 (quote ()) #:cc (lambda ($tmp$$111 )  (cons (quote let*) $tmp$$111 #:cc (lambda ($tmp$$112 )  (cons eval-letrec (quote ()) #:cc (lambda ($tmp$$113 )  (cons (quote syntax-primitive) $tmp$$113 #:cc (lambda ($tmp$$114 )  (cons $tmp$$114 (quote ()) #:cc (lambda ($tmp$$115 )  (cons (quote letrec) $tmp$$115 #:cc (lambda ($tmp$$116 )  (cons eval-begin (quote ()) #:cc (lambda ($tmp$$117 )  (cons (quote syntax-primitive) $tmp$$117 #:cc (lambda ($tmp$$118 )  (cons $tmp$$118 (quote ()) #:cc (lambda ($tmp$$119 )  (cons (quote begin) $tmp$$119 #:cc (lambda ($tmp$$120 )  (cons eval-set! (quote ()) #:cc (lambda ($tmp$$121 )  (cons (quote syntax-primitive) $tmp$$121 #:cc (lambda ($tmp$$122 )  (cons $tmp$$122 (quote ()) #:cc (lambda ($tmp$$123 )  (cons (quote set!) $tmp$$123 #:cc (lambda ($tmp$$124 )  (cons eval-lambda (quote ()) #:cc (lambda ($tmp$$125 )  (cons (quote syntax-primitive) $tmp$$125 #:cc (lambda ($tmp$$126 )  (cons $tmp$$126 (quote ()) #:cc (lambda ($tmp$$127 )  (cons (quote lambda) $tmp$$127 #:cc (lambda ($tmp$$128 )  (cons eval-macro (quote ()) #:cc (lambda ($tmp$$129 )  (cons (quote syntax-primitive) $tmp$$129 #:cc (lambda ($tmp$$130 )  (cons $tmp$$130 (quote ()) #:cc (lambda ($tmp$$131 )  (cons (quote macro) $tmp$$131 #:cc (lambda ($tmp$$132 )  (cons $tmp$$132 (quote ()) #:cc (lambda ($tmp$$133 )  (cons $tmp$$128 $tmp$$133 #:cc (lambda ($tmp$$134 )  (cons $tmp$$124 $tmp$$134 #:cc (lambda ($tmp$$135 )  (cons $tmp$$120 $tmp$$135 #:cc (lambda ($tmp$$136 )  (cons $tmp$$116 $tmp$$136 #:cc (lambda ($tmp$$137 )  (cons $tmp$$112 $tmp$$137 #:cc (lambda ($tmp$$138 )  (cons $tmp$$108 $tmp$$138 #:cc (lambda ($tmp$$139 )  (cons $tmp$$104 $tmp$$139 #:cc (lambda ($tmp$$140 )  (cons $tmp$$100 $tmp$$140 #:cc (lambda ($tmp$$141 )  (cons $tmp$$96 $tmp$$141 #:cc (lambda ($tmp$$142 )  (cons $tmp$$92 $tmp$$142 #:cc (lambda ($tmp$$143 )  (cons $tmp$$88 $tmp$$143 #:cc (lambda ($tmp$$144 )  (cons $tmp$$84 $tmp$$144 #:cc (lambda ($tmp$$145 )  (cons $tmp$$82 $tmp$$145 #:cc (lambda ($tmp$$146 )  (cons $tmp$$80 $tmp$$146 #:cc (lambda ($tmp$$147 )  (cons $tmp$$78 $tmp$$147 #:cc (lambda ($tmp$$148 )  (cons $tmp$$76 $tmp$$148 #:cc (lambda ($tmp$$149 )  (cons $tmp$$74 $tmp$$149 #:cc (lambda ($tmp$$150 )  (cons $tmp$$72 $tmp$$150 #:cc (lambda ($tmp$$151 )  (cons $tmp$$70 $tmp$$151 #:cc (lambda ($tmp$$152 )  (cons $tmp$$68 $tmp$$152 #:cc (lambda ($tmp$$153 )  (cons $tmp$$66 $tmp$$153 #:cc (lambda ($tmp$$154 )  (cons $tmp$$64 $tmp$$154 #:cc (lambda ($tmp$$155 )  (cons $tmp$$62 $tmp$$155 #:cc (lambda ($tmp$$156 )  (cons $tmp$$60 $tmp$$156 #:cc (lambda ($tmp$$157 )  (cons $tmp$$58 $tmp$$157 #:cc (lambda ($tmp$$158 )  (cons $tmp$$56 $tmp$$158 #:cc (lambda ($tmp$$159 )  (cons $tmp$$54 $tmp$$159 #:cc (lambda ($tmp$$160 )  (cons $tmp$$52 $tmp$$160 #:cc (lambda ($tmp$$161 )  (cons $tmp$$50 $tmp$$161 #:cc (lambda ($tmp$$162 )  (cons $tmp$$48 $tmp$$162 #:cc (lambda ($tmp$$163 )  (cons $tmp$$46 $tmp$$163 #:cc (lambda ($tmp$$164 )  (cons $tmp$$44 $tmp$$164 #:cc (lambda ($tmp$$165 )  (cons $tmp$$42 $tmp$$165 #:cc (lambda ($tmp$$166 )  (cons $tmp$$40 $tmp$$166 #:cc (lambda ($tmp$$167 )  (cons $tmp$$38 $tmp$$167 #:cc (lambda ($tmp$$168 )  (begin  (set! initial-environment-amap $tmp$$168) ((lambda _$$35  ((lambda _$$34  (begin  (set! initial-environment (lambda ( #:cc cc$$5)  (unzip-amap-k initial-environment-amap (lambda (symbols values #:cc cc$$6)  (env-extend* empty-env symbols values #:cc cc$$6)) #:cc cc$$5))) ((lambda _$$33  ((lambda _$$32  (begin  (set! initial (lambda (sym #:cc cc$$4)  (initial-environment  #:cc (lambda ($tmp$$36 )  (env-lookup $tmp$$36 sym #:cc cc$$4))))) ((lambda _$$31  ((lambda _$$30  (begin  (set! three-d (lambda (value #:cc cc$$2)  (cc$$2 (lambda ( #:cc cc$$3)  (cc$$3 value )) ))) ((lambda _$$29  ((lambda _$$28  (initial (quote quote) #:cc (lambda ($tmp$$34 )  (three-d $tmp$$34 #:cc (lambda ($tmp$$35 )  (begin  (set! three-d-quote $tmp$$35) ((lambda _$$27  ((lambda _$$26  (initial (quote if) #:cc (lambda ($tmp$$32 )  (three-d $tmp$$32 #:cc (lambda ($tmp$$33 )  (begin  (set! three-d-if $tmp$$33) ((lambda _$$25  ((lambda _$$24  (initial (quote cond) #:cc (lambda ($tmp$$30 )  (three-d $tmp$$30 #:cc (lambda ($tmp$$31 )  (begin  (set! three-d-cond $tmp$$31) ((lambda _$$23  ((lambda _$$22  (initial (quote and) #:cc (lambda ($tmp$$28 )  (three-d $tmp$$28 #:cc (lambda ($tmp$$29 )  (begin  (set! three-d-and $tmp$$29) ((lambda _$$21  ((lambda _$$20  (initial (quote or) #:cc (lambda ($tmp$$26 )  (three-d $tmp$$26 #:cc (lambda ($tmp$$27 )  (begin  (set! three-d-or $tmp$$27) ((lambda _$$19  ((lambda _$$18  (initial (quote let) #:cc (lambda ($tmp$$24 )  (three-d $tmp$$24 #:cc (lambda ($tmp$$25 )  (begin  (set! three-d-let $tmp$$25) ((lambda _$$17  ((lambda _$$16  (initial (quote let*) #:cc (lambda ($tmp$$22 )  (three-d $tmp$$22 #:cc (lambda ($tmp$$23 )  (begin  (set! three-d-let* $tmp$$23) ((lambda _$$15  ((lambda _$$14  (initial (quote letrec) #:cc (lambda ($tmp$$20 )  (three-d $tmp$$20 #:cc (lambda ($tmp$$21 )  (begin  (set! three-d-letrec $tmp$$21) ((lambda _$$13  ((lambda _$$12  (initial (quote set!) #:cc (lambda ($tmp$$18 )  (three-d $tmp$$18 #:cc (lambda ($tmp$$19 )  (begin  (set! three-d-set! $tmp$$19) ((lambda _$$11  ((lambda _$$10  (initial (quote lambda) #:cc (lambda ($tmp$$16 )  (three-d $tmp$$16 #:cc (lambda ($tmp$$17 )  (begin  (set! three-d-lambda $tmp$$17) ((lambda _$$9  ((lambda _$$8  (initial (quote begin) #:cc (lambda ($tmp$$14 )  (three-d $tmp$$14 #:cc (lambda ($tmp$$15 )  (begin  (set! three-d-begin $tmp$$15) ((lambda _$$7  ((lambda _$$6  (begin  (set! perform-apply (lambda (fun app-exp env #:cc cc$$1)  (app->args app-exp #:cc (lambda (args )  (macro? fun #:cc (lambda ($tmp$$9 )  (if $tmp$$9 (macro->proc fun #:cc (lambda ($tmp$$10 )  (apply $tmp$$10 args #:cc (lambda ($tmp$$11 )  (eval $tmp$$11 env #:cc cc$$1))))) (syntax-primitive? fun #:cc (lambda ($tmp$$12 )  (if $tmp$$12 (syntax-primitive->eval fun #:cc (lambda ($tmp$$13 )  ($tmp$$13 app-exp env #:cc cc$$1))) (eval* args env #:cc (lambda (arg-values )  (apply fun arg-values #:cc cc$$1))))))))))))) ((lambda _$$5  ((lambda _$$4  (cons (quote x) (quote ()) #:cc (lambda ($tmp$$1 )  (cons (quote x) (quote ()) #:cc (lambda ($tmp$$2 )  (cons $tmp$$1 $tmp$$2 #:cc (lambda ($tmp$$3 )  (cons (quote lambda) $tmp$$3 #:cc (lambda ($tmp$$4 )  (cons (quote 10) (quote ()) #:cc (lambda ($tmp$$5 )  (cons $tmp$$4 $tmp$$5 #:cc (lambda ($tmp$$6 )  (initial-environment  #:cc (lambda ($tmp$$7 )  (eval $tmp$$6 $tmp$$7 #:cc (lambda ($tmp$$8 )  (begin  (set! _$$1 $tmp$$8) ((lambda _$$3  ((lambda _$$2  ((lambda (answer )  answer) _$$1 )) (void) )) (void) ))))))))))))))))))) (void) )) (void) ))) (void) )) (void) ))))))) (void) )) (void) ))))))) (void) )) (void) ))))))) (void) )) (void) ))))))) (void) )) (void) ))))))) (void) )) (void) ))))))) (void) )) (void) ))))))) (void) )) (void) ))))))) (void) )) (void) ))))))) (void) )) (void) ))))))) (void) )) (void) ))))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) (void) )) (void) ))) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )) 'undefined )


Free variables:
Set(cons, symbol->string, number->string, cdr, reverse, newline, string?, eq?, car, not, error, length, pair?, boolean?, equal?, eqv?, cdadr, string-length, display, list?, <, null?, procedure?, symbol?, =, string-append, string->symbol, +, string-ref, number?)


States explored: 655
inlinable: 255
